{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-the-raspirus-documentation","title":"Welcome to the Raspirus Documentation","text":""},{"location":"#table-of-contents","title":"Table of Contents:","text":"<ul> <li>Introduction</li> <li>Installation</li> <li>Guides</li> <li>FAQ</li> <li>Usage and Diagrams</li> <li>Developers Section<ul> <li>Frontend (Next.js)</li> <li>Backend (Rust)</li> </ul> </li> <li>Contributing<ul> <li>Coding</li> <li>Translations</li> </ul> </li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the Raspirus project documentation. This repository serves as a comprehensive guide to the Raspirus project. Please note that the project is currently under development, and while we strive for accuracy, some information may be subject to change.</p>"},{"location":"#related-projects","title":"Related Projects","text":"<p>Raspirus is a simple and efficient virus scanner, specifically designed for compatibility with single-board computers like the Raspberry Pi. While there are several similar projects available, Raspirus stands out for its unique features and advantages. Here are some notable comparisons:</p> <ul> <li> <p>Clam AV: Clam AV is an open-source antivirus program that can also perform file and folder scanning similar to Raspirus. However, it is known to be resource-intensive and relatively slow. Due to its high memory requirements, it may not be suitable for deployment on low-spec systems like the Raspberry Pi. Nonetheless, Clam AV remains a powerful open-source tool.</p> </li> <li> <p>Windows Defender: Windows Defender is a comprehensive security program for Windows that continuously scans the entire system for threats. However, this continuous scanning process can significantly impact system performance. Additionally, Windows Defender is limited to the Windows operating system, whereas Raspirus is designed to be cross-platform, offering compatibility with various operating systems.</p> </li> <li> <p>Bitdefender: Bitdefender is a feature-rich commercial antivirus software solution. While it offers robust security capabilities, it comes at a cost. Raspirus, on the other hand, is committed to being a free and open-source project. We believe that security should be accessible to all users without the need for financial barriers. Furthermore, Raspirus aims to foster a collaborative community, leveraging the collective expertise of developers worldwide.</p> </li> </ul> <p>While there are numerous other antivirus solutions available, it's important to note that Raspirus does not seek to outperform or compete directly with other antivirus software. Instead, its primary focus is to excel at a specific task: comparing file hashes against a list of signatures.</p> <p>Key features of Raspirus include: - Free and open-source nature - Transparent codebase for community review and scrutiny - Emphasis on community-driven growth and development - Cross-platform compatibility as a standard feature - Lightweight and fast performance, ensuring usability even on low-spec devices</p> <p>We invite you to explore the documentation further to gain a comprehensive understanding of the Raspirus project and its capabilities.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Welcome to our FAQ section, where we address some of the most frequently asked questions. If you encounter any errors or have queries during development or usage, this page can provide you with useful information. We continually update this section as new questions arise.</p>"},{"location":"faq/#what-is-the-projects-icon","title":"What is the project's icon?","text":"<p>The logo of the Raspirus app features a red monster named Stuart, who is designed to represent a virus-eating creature. The logo was generated using DALL-E, along with creative image editing and merging. Stuart is a friendly monster, except when he's hungry for viruses. You can find additional media and documents in the dedicated repository. Feel free to use these images to create your own artwork and share them in the discussion boards.</p>"},{"location":"faq/#how-can-i-generate-the-documentation-for-this-repository","title":"How can I generate the documentation for this repository?","text":"<p>The generated documentation can be found in the rust folder. If you want to generate your own documentation, you can use the <code>cargo doc</code> command. Here are some parameters you may find useful:</p> <ul> <li><code>--no-deps</code>: Ignores dependencies and only documents the code itself.</li> <li><code>--release</code>: Generates documentation optimized for release builds.</li> <li><code>--target-dir</code>: Specifies the output directory for the documentation.</li> </ul> <p>Putting it all together, the command might look like this:</p> <pre><code>cargo doc --no-deps --release --target-dir=/docs/generated/\n</code></pre>"},{"location":"faq/#how-do-i-set-up-rust-analyzer-in-vs-code-to-work-with-a-non-standard-directory-structure","title":"How do I set up Rust Analyzer in VS Code to work with a non-standard directory structure?","text":"<p>The Rust Analyzer plugin in Visual Studio Code searches for a <code>Cargo.toml</code> file in the current directory or its parent directory. However, in our case, since the entire application is packed in the <code>app</code> directory, the plugin may not work as expected. To address this issue, you can add an option to the plugin settings and specify the location of your <code>Cargo.toml</code> file.</p> <p>As mentioned in this comment, you can add the following lines to the end of your plugin settings JSON. Afterward, restart the Rust Analyzer for the modifications to take effect.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/stuart/raspirus/raspirus/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"faq/#the-app-crashes-when-updating-the-database","title":"The app crashes when updating the database","text":"<p>On Windows, it has been observed that the app crashes when attempting to update the database. We are aware of this issue and actively working to resolve it. The problem arises because the update function requires administrative privileges, which Windows does not automatically provide. To temporarily resolve this issue, you can execute the app with administrative privileges. Right-click on the app and select \"Run as administrator\" to launch it with the necessary privileges.</p>"},{"location":"guides/","title":"Guides","text":"<p>Here you will find helpful guides on how to export the documentation to PDF format and how to contribute translations to this project. If you have any additional requests for guides, please leave a comment below!</p>"},{"location":"guides/#export-to-pdf","title":"Export to PDF","text":"<p>If you would like to have an offline version of this documentation in PDF format, you can follow these step-by-step instructions:</p> <ol> <li>Clone this repository by following the instructions on GitHub.</li> <li>Install the necessary requirements for the PDF conversion tool. You can find the requirements specific to your operating system here.</li> <li>Navigate to the cloned directory and install the required dependencies. Please note that you will need Python3 and pip for this step. You can install the dependencies by running the following command: <code>pip install -r requirements.txt</code>.</li> <li>Install mkdocs and execute the build command: <code>mkdocs build</code>.</li> <li>If everything goes smoothly, the resulting PDF file should be located in the <code>site/pdf</code> directory with the name <code>document.pdf</code>.</li> </ol> <p>Please be aware that the exported PDF may have some issues with images and iFrames, but the text should be readable and suitable for sharing offline.</p>"},{"location":"guides/#translations","title":"Translations","text":"<p>We welcome contributions to translate this documentation into other languages. If you are interested in translating the document, you can find the necessary information and resources at the following link: Translate this document.</p> <p>Your contributions are highly appreciated, and they will help make this documentation more accessible to a wider audience.</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide provides instructions on how to install the Raspirus application on your machine.</p>"},{"location":"installation/#using-executables","title":"Using Executables","text":"<p>The quickest and simplest method to install the application is by using one of the executables available on the Release page. Once you have downloaded the executable, the installation process may vary depending on your system. For example, on Windows, you can double-click the executable and follow the installation instructions provided by the wizard. Once completed, the installation process is finished.</p>"},{"location":"installation/#using-the-makefile-debian-based-systems-only","title":"Using the Makefile (Debian-based Systems Only)","text":"<p>The project includes a Makefile that facilitates installation, updating, and testing. To install the application, you can clone the repository and execute the Makefile using the following command:</p> <pre><code>make install\n</code></pre>"},{"location":"installation/#limitations","title":"Limitations","text":"<ul> <li>Glibc can cause issues on Linux. Please refer to the limitations section of the Tauri documentation for more information.</li> <li>The application requires a 64-bit system. Running it on a different system architecture may result in crashes due to the utilization of memory improvements specific to 64-bit systems.</li> </ul>"},{"location":"installation/#step-by-step-guide","title":"Step-by-Step Guide","text":"<p>Before executing each step, we recommend reading the entire guide thoroughly.</p>"},{"location":"installation/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<p>If you have <code>git</code> installed, use the following command to clone the repository:</p> <pre><code>git clone https://github.com/Raspirus/Raspirus.git\n</code></pre> <p>Alternatively, you can download the repository as a ZIP file from here and extract its contents. The GitHub guide provides further assistance on this process.</p>"},{"location":"installation/#step-2-install-rust","title":"Step 2: Install Rust","text":"<p>For Linux (Debian, Ubuntu):</p> <pre><code>curl https://sh.rustup.rs -sSf | sh -s -- --help\n</code></pre> <p>For Windows: Download the Rust executable from the Rust website and follow the installation instructions.</p>"},{"location":"installation/#step-3-install-npm","title":"Step 3: Install NPM","text":"<p>For Linux (Debian, Ubuntu):</p> <pre><code>curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash - &amp;&amp; \\\nsudo apt-get install -y nodejs\n</code></pre> <p>For Windows: Visit the NPM Website to download the NPM executable and proceed with the installation.</p>"},{"location":"installation/#step-4-install-nextjs","title":"Step 4: Install Next.js","text":"<p>Use the following command with npm to install Next.js and its dependencies:</p> <pre><code>npm install next@latest react@latest react-dom@latest eslint-config-next@latest\n</code></pre>"},{"location":"installation/#step-5-install-tauri","title":"Step 5: Install Tauri","text":"<p>Tauri is the framework that connects the Rust backend with the Next.js frontend. Follow these steps to install Tauri:</p> <ol> <li>Make sure you meet the Prerequisites specified by Tauri.</li> <li>Install Tauri using cargo with the following command:</li> </ol> <p><code>sh    cargo install tauri-cli</code></p> <p>Note: We primarily work with cargo in this guide. Refer to their FAQ section to learn about the alternative NPM installation.</p>"},{"location":"installation/#step-6-install-project-dependencies","title":"Step 6: Install Project Dependencies","text":"<p>To install the project dependencies, follow these steps:</p> <ol> <li>Navigate to the directory that contains the Raspirus code.</li> <li>Open a terminal in the <code>Raspirus</code> directory.</li> <li>Execute the command <code>npm install</code> to install the necessary node modules.</li> <li>Note: If you encounter an \"OpenSSL is missing\" error on WSL, resolve it by editing the file <code>Raspirus/src-tauri/Cargo.toml</code>. Add the following line to the <code>[dependencies]</code> section: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code>.</li> </ol>"},{"location":"installation/#step-7-build-the-project","title":"Step 7: Build the Project","text":"<p>Before building the project, ensure the Rust part works correctly (optional):</p> <ol> <li>Open the folder <code>Raspirus/src-tauri/</code>.</li> <li>Run the command <code>cargo build</code>.</li> <li>If the command succeeds, return to the <code>Raspirus/</code> directory.</li> <li>If the command fails, please open an issue on this repository, providing detailed information about the error.</li> </ol> <p>To build the entire application:</p> <ol> <li>In the <code>Raspirus/</code> directory, execute the command <code>cargo tauri build</code>.</li> <li>After the process completes, the executable file's path will be displayed.</li> <li>By default, the executable is located in the <code>Raspirus\\src-tauri\\target\\release</code> folder.</li> </ol>"},{"location":"installation/#step-8-install-the-raspirus-debian-package-for-debian-based-systems","title":"Step 8: Install the Raspirus Debian Package (for Debian-based Systems)","text":"<p>For Debian-based systems, an alternative installation method is available using the <code>.deb</code> package generated in the <code>Raspirus/src-tauri/target/release/bundle/deb</code> folder. Follow these steps to install the package:</p> <ol> <li>Open a terminal in the <code>Raspirus/src-tauri/target/release/bundle/deb</code> directory.</li> <li> <p>Execute one of the following commands:</p> </li> <li> <p>Using <code>apt</code>:</p> <p><code>sh  sudo apt install ./raspirus-x.x.x_amd64.deb</code></p> </li> <li> <p>Using <code>dpkg</code>:</p> <p><code>sh  sudo dpkg -i raspirus-x.x.x_amd64.deb</code></p> </li> </ol> <p>Replace <code>x.x.x</code> with the actual version number of the Raspirus package.</p>"},{"location":"installation/#step-9-execute-the-application","title":"Step 9: Execute the Application","text":"<p>After successfully building and installing the Raspirus application, you can execute it using the following command:</p> <pre><code>raspirus\n</code></pre> <p>Executing this command will launch the Raspirus application. Congratulations! You have now completed the installation process and can begin using the Raspirus app.</p>"},{"location":"installation/#conclusion","title":"Conclusion","text":"<p>The Raspirus application combines a website interface with underlying Rust code, packaged using the Tauri framework. To launch and display the website, a graphical overlay is required. As the project is continually evolving, we encourage you to open an issue on the repository if you encounter any unusual behavior, have suggestions, or discover errors. We are here to assist you.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#tutorial","title":"Tutorial","text":"<p>Using the Raspirus app is straightforward and user-friendly. Once you have installed the application, it requires only a few simple steps to perform a scan. The app is designed with a focus on usability for touchscreens and does not require any input devices or keyboards to operate. Here's a step-by-step guide:</p> <ol> <li>Open the app from the main page.</li> <li>Insert a USB drive and select it, or click the folder icon to choose a local folder for scanning.</li> <li>Carefully review and accept the user agreement.</li> <li>Allow the app to perform its scanning process.</li> <li>The results will be displayed, and you can initiate a new scan if necessary.</li> </ol>"},{"location":"usage/#case-study","title":"Case Study","text":"<p>Let's delve into some key metrics and specifications of the Raspirus app, evaluating its speed, reliability, and functionality. Additionally, we will outline the intended use of the application.</p>"},{"location":"usage/#specifications","title":"Specifications","text":"<ul> <li>App size: 5MB</li> <li>RAM usage: Approximately 50MB</li> <li>Works offline, requiring an internet connection only for database file updates</li> </ul>"},{"location":"usage/#performance-metrics","title":"Performance Metrics","text":"<p>The scanning speed of the app depends on three factors: - The storage medium (USB or local) used for scanning. - The CPU performance of the system running the app. - The file size of individual files being scanned.</p> <p>For optimal scanning speed, it is recommended to utilize modern storage media with high read speeds, employ a capable CPU that is not overwhelmed with other applications, and focus on scanning smaller files. Scanning 100 files of 10GB each will generally be faster than scanning a single 10GB file, as the hashing function performs more efficiently on smaller files. For Raspberry Pis, CPU speed is of greater importance than RAM capacity, as the app only requires a few megabytes of memory.</p>"},{"location":"usage/#application-scope","title":"Application Scope","text":"<p>Initially developed for Raspberry Pis with touchscreens, the Raspirus app offers easy setup and high security on Linux-based systems. Given that most viruses target Windows PCs, Linux-based Raspberry Pis are inherently less vulnerable. Additionally, by configuring a Raspberry Pi with a battery and enabling Kiosk mode, it is possible to create a portable Raspirus scanning box specifically tailored for scanning USB drives.</p> <p>Thanks to Tauri's cross-compilation feature, the Raspirus app is now available for macOS, Windows, and Linux. While primarily developed and tested on Windows and Debian Linux, installation instructions for various operating systems can be found on the Installation page.</p>"},{"location":"contributing/","title":"Index.md","text":""},{"location":"contributing/#contributing-to-raspirus","title":"Contributing to Raspirus","text":"<p>First off, thanks for taking the time to contribute! \u2764\ufe0f</p> <p>All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for all involved. The community looks forward to your contributions. \ud83c\udf89</p> <p>And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about: - Star the project - Tweet about it - Refer this project in your project's readme - Mention the project at local meetups and tell your friends/colleagues</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>I Have a Question</li> <li>I Want To Contribute</li> <li>Reporting Bugs</li> <li>Suggesting Enhancements</li> <li>Your First Code Contribution</li> <li>Improving The Documentation</li> <li>Adding translations</li> <li>Styleguides</li> <li>Commit Messages</li> <li>Join The Project Team</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and everyone participating in it is governed by the Raspirus Code of Conduct. By participating, you are expected to uphold this code. Please report unacceptable behaviour to demetzbenjamin@duck.com.</p>"},{"location":"contributing/#i-have-a-question","title":"I Have a Question","text":"<p>If you want to ask a question, we assume that you have read the available Documentation.</p> <p>Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.</p> <p>If you then still feel the need to ask a question and need clarification, we recommend the following:</p> <ul> <li>Open an Issue.</li> <li>Provide as much context as you can about what you're running into.</li> <li>Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant.</li> <li>If the question is about the docs, write a comment at the bottom of the said page.</li> </ul> <p>We will then take care of the issue as soon as possible.</p>"},{"location":"contributing/#i-want-to-contribute","title":"I Want To Contribute","text":""},{"location":"contributing/#legal-notice","title":"Legal Notice","text":"<p>When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project licence.</p>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":""},{"location":"contributing/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<p>A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.</p> <ul> <li>Make sure that you are using the latest version.</li> <li>Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation. If you are looking for support, you might want to check this section).</li> <li>To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker.</li> <li>Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue.</li> <li>Collect information about the bug:</li> <li>Stack trace (Traceback)</li> <li>OS, Platform and Version (Windows, Linux, macOS, x86, ARM)</li> <li>Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.</li> <li>Possibly your input and the output</li> <li>Can you reliably reproduce the issue? And can you also reproduce it with older versions?</li> </ul>"},{"location":"contributing/#how-do-i-submit-a-good-bug-report","title":"How Do I Submit a Good Bug Report?","text":"<p>You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to demetzbenjamin@duck.com.</p> <p>We use GitHub issues to track bugs and errors. If you run into an issue with the project:</p> <ul> <li>Open an Issue. (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)</li> <li>Explain the behaviour you would expect and the actual behaviour.</li> <li>Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.</li> <li>Provide the information you collected in the previous section.</li> </ul> <p>Once it's filed:</p> <ul> <li>The project team will label the issue accordingly.</li> <li>A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as <code>needs-repro</code>. Bugs with the <code>needs-repro</code> tag will not be addressed until they are reproduced.</li> <li>If the team is able to reproduce the issue, it will be marked <code>needs-fix</code>, as well as possibly other tags (such as <code>critical</code>), and the issue will be left to be implemented by someone.</li> </ul>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>This section guides you through submitting an enhancement suggestion for Raspirus, including completely new features and minor improvements to existing functionality. Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.</p>"},{"location":"contributing/#before-submitting-an-enhancement","title":"Before Submitting an Enhancement","text":"<ul> <li>Make sure that you are using the latest version.</li> <li>Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration.</li> <li>Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.</li> <li>Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.</li> </ul>"},{"location":"contributing/#how-do-i-submit-a-good-enhancement-suggestion","title":"How Do I Submit a Good Enhancement Suggestion?","text":"<p>Enhancement suggestions are tracked as GitHub issues.</p> <ul> <li>Use a clear and descriptive title for the issue to identify the suggestion.</li> <li>Provide a step-by-step description of the suggested enhancement in as many details as possible.</li> <li>Describe the current behaviour and explain which behaviour you expected to see instead and why. At this point you can also tell which alternatives do not work for you.</li> <li>You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. </li> <li>Explain why this enhancement would be useful to most Raspirus users. You may also want to point out the other projects that solved it better and which could serve as inspiration.</li> </ul>"},{"location":"contributing/#attribution","title":"Attribution","text":"<p>This guide is based on the contributing-gen. Make your own!</p>"},{"location":"contributing/CODE_OF_CONDUCT/","title":"Code of Conduct - Raspirus","text":""},{"location":"contributing/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"contributing/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behaviour that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologising to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behaviour include:</p> <ul> <li>The use of sexualised language or imagery, and sexual attention or advances</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contributing/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying and enforcing our standards of acceptable behaviour and will take appropriate and fair corrective action in response to any instances of unacceptable behaviour.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviours that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"contributing/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behaviour may be reported to the community leaders responsible for enforcement at demetzbenjamin@duck.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4 and 2.0, and was generated by contributing-gen.</p>"},{"location":"contributing/artwork/","title":"Media Resources","text":"<p>In the Raspirus project, we recognize the importance of visual elements to enhance the user experience, provide clarity, and make documentation more engaging. We maintain a dedicated repository, Raspirus/media, which hosts various media resources, including images, artworks, diagrams, PDF documents, and more.</p>"},{"location":"contributing/artwork/#accessing-media-resources","title":"Accessing Media Resources","text":"<p>To access the media repository and explore the available resources, follow these steps:</p> <ol> <li>Visit the Raspirus/media repository on GitHub.</li> <li>Browse through the repository to discover images, artworks, diagrams, PDF documents, and other visual assets that may be relevant to your needs.</li> </ol>"},{"location":"contributing/artwork/#utilizing-media-resources","title":"Utilizing Media Resources","text":"<p>Feel free to utilize the media resources from the Raspirus/media repository in your contributions to the project. Whether you're creating documentation, designing user interfaces, or adding visual elements to enhance communication, these resources can greatly assist in conveying information effectively.</p>"},{"location":"contributing/artwork/#contributing-your-own-visual-assets","title":"Contributing Your Own Visual Assets","text":"<p>We highly encourage community members to contribute their own artwork, images, diagrams, or other visual content to the project. By doing so, you can help enhance the visual appeal of Raspirus and contribute to the overall project experience.</p> <p>To contribute your own visual assets, follow these steps:</p> <ol> <li>Fork the Raspirus/media repository to create a personal copy in your GitHub account.</li> <li>Add your visual assets to the appropriate folders within the repository, ensuring proper organization and categorization.</li> <li>Submit a pull request from your forked repository to the original Raspirus/media repository, indicating the changes you've made and providing a brief description of your contribution.</li> </ol> <p>Once your pull request is reviewed and accepted by the team, your visual assets will be added to the media repository and made available to other contributors.</p> <p>Feel free to customize and expand on this template to suit your specific needs. It's important to provide clear instructions, guidelines, and encouragement for contributors to utilize and contribute to the media resources effectively.</p>"},{"location":"contributing/coding/","title":"Code Contributions","text":"<p>Contributions to the codebase are always welcome and highly valued in the development of Raspirus, a powerful virus scanner. If you're interested in contributing code, please take a moment to familiarize yourself with our Guidelines before opening a pull request. Additionally, we recommend exploring the coding practices and standards outlined in the Developer section for a comprehensive understanding of our project's structure and requirements.</p>"},{"location":"contributing/coding/#contributing-to-the-frontend","title":"Contributing to the Frontend","text":"<p>The frontend of Raspirus is built using the Next.js framework and leverages JavaScript for its implementation. To maintain a clean and efficient codebase, we prioritize modularizing components and ensuring that pages remain uncluttered with unnecessary code. Each page represents a distinct screen within the app and can be accessed either through manual routing or as a result of specific user actions, such as clicking a button or being redirected after the completion of a loading process.</p> <p>When contributing to the frontend, consider the following guidelines:</p> <ul> <li>Emphasize clean and intuitive user interfaces, allowing users to navigate the app effortlessly.</li> <li>Utilize the Next.js structure effectively, leveraging the power of components for enhanced maintainability and reusability.</li> <li>While the frontend is currently developed exclusively in JavaScript, we remain open to migrating to TypeScript in the future.</li> </ul> <p>Your contributions to the frontend will significantly impact the user experience of Raspirus, making it more accessible and user-friendly.</p>"},{"location":"contributing/coding/#adding-to-the-backend","title":"Adding to the Backend","text":"<p>The backend of Raspirus is implemented in Rust, a high-performance programming language renowned for its speed and reliability. By utilizing Rust, we achieve faster scanning speeds and enhance the overall robustness of the application. The backend interacts with a sizable database, locally storing hashes, and communicates responses via the Tauri API.</p> <p>If you're interested in contributing to the backend, consider the following points:</p> <ul> <li>Familiarize yourself with Tauri, a framework that facilitates the integration of Rust and JavaScript, enabling seamless communication between the frontend and backend.</li> <li>Explore Rust's features and capabilities, which provide an efficient and secure foundation for the virus scanning process.</li> <li>Although learning Rust and Tauri might seem daunting at first, with a little practice, you can quickly grasp the concepts and contribute effectively to the backend development.</li> </ul> <p>Contributing to the backend of Raspirus will help improve its scanning capabilities and ensure the reliability of the application.</p> <p>We appreciate your interest in contributing code to Raspirus, and we look forward to your valuable contributions that will help make our project even better.</p>"},{"location":"contributing/translations/","title":"Translators","text":"<p>Translations play a vital role in making the app accessible to users worldwide. If you are fluent in a language other than English and would like to contribute by providing translations, we welcome your assistance. There are two main areas where you can contribute: translating code and translating documentation.</p>"},{"location":"contributing/translations/#translating-code","title":"Translating Code","text":"<p>Translating the app's frontend strings is an essential task that allows users to interact with the app in their native language. There are two possible ways to handle translations within the codebase:</p>"},{"location":"contributing/translations/#translation-file","title":"Translation File","text":"<p>Each language has its own translation file in JSON format. The app loads the required strings from these files. While this approach is relatively simpler for developers to implement, it may not be the most efficient or user-friendly for translators, as it involves forking the repository and manually editing the JSON file.</p>"},{"location":"contributing/translations/#translation-service","title":"Translation Service","text":"<p>To streamline the translation process and provide a better experience for translators, we plan to integrate an external translation service. This service would enable translators to focus solely on translating the strings and provide an overview of the progress. We are considering using Crowdin as the preferred translation service. However, the setup for this option is still being worked on, and it will be added in the future as the team expands and we have more concrete plans.</p>"},{"location":"contributing/translations/#translating-documentation","title":"Translating Documentation","text":"<p>The documentation itself also requires translations to make it accessible to users who are more comfortable in languages other than English. Translating the documentation is a more significant undertaking compared to translating frontend strings. If you are eager to contribute translations to the documentation, follow these steps:</p> <ol> <li>Fork this repository: You can find a comprehensive guide on how to fork a repository here.</li> <li>Navigate to the <code>docs</code> folder in the forked repository. If the language you want to translate to doesn't exist yet, create a new directory with the name of the language you wish to translate into (e.g., <code>it</code> for Italian, <code>de</code> for German).</li> <li>Enter the language directory and start editing the Markdown files while maintaining the original folder structure.</li> <li>Once you have finished the translations, save your files and upload them to your forked repository. You can commit your changes following the GitHub commit guide.</li> <li>Finally, open a pull request to the original repository, proposing your changes to be added to the main project.</li> <li>A member of our team will review your translations and, if accepted, merge them into the main project.</li> </ol> <p>We understand that this manual process might be cumbersome, but rest assured that in the future, we plan to integrate an external service like Crowdin. This service will simplify the translation workflow, allowing you to focus solely on your translations without any distractions.</p> <p>We appreciate your contribution to making the app accessible to a global audience through your translations. Thank you for your support!</p>"},{"location":"developers/","title":"Developers","text":"<p>The Raspirus project employs two distinct programming languages and frameworks: one for the frontend and one for the backend. The frontend utilizes JavaScript with the Next.js framework, while the backend is built with Rust. Communication between these languages is facilitated by the Tauri framework, enabling seamless integration of Rust functions in the frontend.</p>"},{"location":"developers/#technologies-used","title":"Technologies Used","text":"<ul> <li>NPM:   To achieve an aesthetically pleasing frontend, I explored native application development options initially. However, the customization capabilities fell short of my expectations. Consequently, I opted for a web-based frontend and selected Node.js over Deno due to my familiarity with Node.js.</li> <li>Next.js:   Next.js, a frontend framework, proved to be easy to implement and incredibly powerful once set up. The project extensively leverages Next.js's capability to export the website as static HTML, which is crucial for the functioning of Tauri. Additionally, Next.js optimizes the application by automatically eliminating unnecessary components, resulting in a lightweight and fast application. Navigation with Next.js is nearly instantaneous.</li> <li>Rust:   While C++ was my initial choice for the backend, my proficiency wasn't sufficient to develop the entire application in that language. I turned to Python, my preferred language and one in which I am proficient, for faster development. However, Python's speed limitations became a significant drawback. Fortunately, a friend helped rewrite the entire backend in Rust, boosting the application's speed by 100x. Rust's compilation-based approach and performance superiority over interpreted languages like Python made it an ideal choice. If you are interested in the previous Python implementation, you can refer to the dedicated repository.</li> <li>Tauri:   Tauri plays a vital role in this project by bridging the Rust backend with the JavaScript frontend. This allows us to have an elegant frontend with Next.js and an impressively fast backend with Rust. Furthermore, Tauri simplifies the compilation of the application into installers or binaries for different systems like Windows, Linux, or macOS, greatly enhancing the installation experience.</li> <li>SweetAlert2:   When presenting errors, warnings, or information to the user as pop-ups, the default JavaScript alert lacks visual appeal. SweetAlert2 significantly enhances the appearance of these pop-ups. It is easy to install and use. In our case, SweetAlert2 is mainly used for displaying errors or warnings, such as when the scanning process is abruptly interrupted.</li> <li>next-i18next:   Although the application contains minimal text and relies on icons and colors for clarity, we decided to incorporate translations. This is achieved using the Next.js plugin called i18next, which facilitates easy translation management through .JSON files.</li> <li>Crowdin:   Crowdin is a website that aids in translating open-source and private projects, and I am particularly grateful that it offers free pricing for open-source projects. Crowdin allows translators to focus solely on translations without the need to examine code. It also streamlines the translation synchronization process between Crowdin and GitHub.</li> <li>MkDocs:   MkDocs, a Python framework, is utilized to generate project documentation. In fact, this very translation you are reading was created using MkDocs. It is user-friendly and facilitates document structuring and integration with plugins like</li> </ul> <p>Crowdin. - Dependabot:   Dependabot, a built-in feature in GitHub repositories, ensures that dependencies are up to date by automatically checking for updates. This helps maintain an up-to-date application with the latest patches and functionality. By improving dependencies, the application's performance and efficiency can be enhanced. Moreover, Dependabot notifies users of any security vulnerabilities in the utilized dependencies or crates, ensuring the application's security. - GitHub:   GitHub was selected as the file hosting platform due to its popularity, user-friendly interface, and comprehensive feature set. Additionally, it offers free hosting. Although a company suggested hosting the project on their GitLab servers, GitHub's ease of use and collaboration capabilities prevailed over the complexities of utilizing a VPN to connect to a PC that connects to GitLab. GitHub offers numerous features, including project planning, milestones, issues, and actions. - CodeQL:   CodeQL, another powerful tool from GitHub, scans the project for vulnerabilities in the code. It detects issues like cross-site scripting, improper handling of passwords and secrets, and inefficient coding practices. CodeQL ensures a higher level of code reliability. - CodeCov:   Codecov, an external tool installable on GitHub, tracks test coverage. It provides insights into the effectiveness of written tests and their coverage across the entire project. Although testing the frontend is challenging as it often involves user interaction, testing the backend is feasible. Therefore, we integrated Codecov to monitor test coverage in our Rust backend.</p>"},{"location":"developers/#integration","title":"Integration","text":"<p>Raspirus is a self-contained application, operating solely within its environment. There are no external APIs for retrieving information, nor is the application designed for integration with other apps. The primary user interaction occurs via a touchscreen interface, eliminating the need for text input fields, which can be frustrating on low-quality touchscreens like the one found on a Raspberry Pi.</p> <p>Although API calls are made, they are internal to the application. For instance, in the <code>loading.js</code> file, we invoke the scanning function from the frontend to initiate the scanner in Rust:</p> <pre><code>const message = await invoke(\"start_scanner\", {\n    path: scan_path,\n    dbfile: db_location,\n    obfuscated: obfuscatedMode,\n});\n</code></pre> <p>The <code>start_scanner</code> function is called with the required parameters, and the resulting message is stored in the <code>message</code> constant. This basic Tauri API call enables seamless communication between the frontend and backend.</p> <p>To send data from the backend to the frontend, Tauri employs the signal principle:</p> <pre><code>fn calculate_progress(&amp;mut self, last_percentage: &amp;mut f64, file_size: u64) {\n    self.scanned_size += file_size;\n    let scanned_percentage = (self.scanned_size as f64 / self.folder_size as f64 * 100.0).round();\n    info!(\"Scanned: {}%\", scanned_percentage);\n    if scanned_percentage != *last_percentage {\n        self.tauri_window.emit_all(\"progress\", TauriEvent { message: scanned_percentage.to_string() }).unwrap();\n        *last_percentage = scanned_percentage;\n    }\n}\n</code></pre> <p>For further details on how this internal API system operates, refer to the official Tauri guide.</p>"},{"location":"developers/backend/","title":"Backend","text":"<p>In the backend of the Raspirus app, several components work together to provide the desired functionality. This section outlines the planning, database structure, scanner, and logging aspects of the backend.</p>"},{"location":"developers/backend/#planning","title":"Planning","text":"<p>The activity diagrams below illustrate the logical flow of the app. While the exact flow may evolve over time, these diagrams represent the initial planning of the app. The backend follows a relatively straightforward design, utilizing if statements and a for-each loop. The complexity lies in managing the database, scanning files, creating hashes, and communicating the results to the frontend through signal emissions.</p> <p>Activity Diagram:  </p>"},{"location":"developers/backend/#database","title":"Database","text":"<p>The database consists of a single large file with two main columns. This file is generated at runtime and can be updated through a button on the GUI. At the time of writing, the database file is approximately 4 GB in size and can take up to an hour to generate. The first column contains all signatures as primary keys, while the second column contains the corresponding file names extracted from the Virusshare database file names.</p>"},{"location":"developers/backend/#structure","title":"Structure","text":"<p>The database structure is as follows:</p> MD5 Hash FileNr .... .... 40610db6af6eaf2391b7a169e2540de9 00219 64a613db4aa368108e6d4c15ef7f6454 00219 .... ...."},{"location":"developers/backend/#initialization","title":"Initialization","text":"<p>The following Rust code in the <code>main.rs</code> file creates the database:</p> <pre><code>let mut use_db = \"signatures.db\".to_owned();\nmatch dbfile {\n    Some(fpath) =&gt; {\n        if Path::new(&amp;fpath).to_owned().exists() &amp;&amp; Path::new(&amp;fpath).to_owned().is_file() {\n            info!(\"Using specific DB path {}\", fpath);\n            use_db = fpath.to_owned();\n        } else {\n            info!(\"Falling back to default DB file (signatures.db)\");\n        }\n    }\n    None =&gt; {\n        info!(\"Path is None; Falling back to default DB file (signatures.db)\");\n    }\n};\n</code></pre> <p>If the specified <code>signatures.db</code> file doesn't exist, the code will attempt to create it and the necessary table. You can also provide your own file by placing it in the same folder as the executable. Just ensure that the table structure is the same.</p>"},{"location":"developers/backend/#scanner","title":"Scanner","text":"<p>The scanner class is the core function of the app. It takes a directory as a parameter and starts scanning it. It recursively scans all folders and files by hashing them and checking the hash in the database for matches.</p>"},{"location":"developers/backend/#ignoring-hashes-false-positives","title":"Ignoring Hashes (False Positives)","text":"<p>In the <code>file_scanner.rs</code> file, where the scanner is defined, there is an array that contains signatures to be ignored. Since Virusshare primarily adds hashes and rarely removes them, we need to handle filtering on the client-side. For example, if there is a hash for empty files, we added an exemption to prevent them from being flagged as dangerous:</p> <pre><code>let false_pos: Vec&lt;String&gt; = vec![\"7dea362b3fac8e00956a4952a3d4f474\".to_owned()];\n</code></pre>"},{"location":"developers/backend/#obfuscated-mode","title":"Obfuscated Mode","text":"<p>To address privacy concerns, the scanner offers an \"Obfuscated mode.\" When enabled, the app immediately fails upon finding a virus without scanning the entire folder</p> <p>. It outputs red or green depending on the security of the scan, without revealing the path and names of the detected files.</p>"},{"location":"developers/backend/#logging","title":"Logging","text":"<p>The app incorporates a logger that tracks issues or warnings during execution. However, the logger only functions in <code>dev</code> or <code>debug</code> mode. When packing the app into an executable, the logger is stripped away for improved performance. Efforts are underway to reintroduce logging functionality in the future.</p>"},{"location":"developers/cross-compile/","title":"How to Cross-Compile Raspirus for the Raspberry Pi","text":"<p>Note: The following guide explains how to cross-compile the Raspirus application from a Linux machine to run on a Raspberry Pi. Please ensure that you have a Linux machine with GLIBC compatible with your target Raspberry Pi.</p>"},{"location":"developers/cross-compile/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding with the cross-compilation process, ensure that you have the following:</p> <ul> <li>A Linux machine with GLIBC compatible with the target Raspberry Pi.</li> </ul>"},{"location":"developers/cross-compile/#initial-setup","title":"Initial Setup","text":"<p>To begin cross-compiling Raspirus, follow these initial setup steps to install Rust, Node.js, Tauri, and their dependencies:</p> <ol> <li>Update the Linux distribution:</li> </ol> <p><code>sh    sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</code></p> <ol> <li>Install Tauri system requirements by executing the following command:</li> </ol> <p><code>sh    sudo apt install libwebkit2gtk-4.0-dev \\        build-essential \\        curl \\        wget \\        libssl-dev \\        libgtk-3-dev \\        libayatana-appindicator3-dev \\        librsvg2-dev</code></p> <ol> <li>Install Rust by running the following command:</li> </ol> <p><code>sh    curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh</code></p> <p>Ensure that Rust is up-to-date:</p> <p><code>sh    rustup update</code></p> <ol> <li>Install Tauri using Cargo, the Rust package manager:</li> </ol> <p><code>sh    cargo install tauri-cli</code></p> <ol> <li> <p>Install Node.js using your preferred method. For example, on Windows WSL, you can follow this guide. The steps involve installing NVM (Node Version Manager) and then installing Node.js using NVM.</p> </li> <li> <p>Remove any existing <code>node_modules</code> directory from the project folder:</p> </li> </ol> <p><code>sh    sudo rm -rf node_modules</code></p> <ol> <li>Install the required Node.js modules:</li> </ol> <p><code>sh    npm install</code></p> <ol> <li>Important! If you are using Linux WSL, add the following dependency to the <code>Cargo.toml</code> file located in <code>&lt;project-root&gt;/src-tauri/</code>:</li> </ol> <p>In the <code>[dependencies]</code> section, add the following line:</p> <p><code>toml    openssl-sys = { version = \"0.9.66\", features = [\"vendored\"] }</code></p>"},{"location":"developers/cross-compile/#cross-compiling","title":"Cross-Compiling","text":"<p>The following steps explain how to compile Raspirus for the Raspberry Pi on an x86_64 Linux host:</p> <ol> <li>Install the Rust target for the Raspberry Pi:</li> </ol> <p><code>sh    rustup target add armv7-unknown-linux-gnueabihf</code></p> <ol> <li>Install the linker for ARM:</li> </ol> <p><code>sh    sudo apt install gcc-arm-linux-gnueabihf</code></p> <ol> <li>Open or create the file <code>.cargo/config.toml</code> in the project root directory and add the following:</li> </ol> <p><code>toml    [target.armv7-unknown-linux-gnueabihf]    linker = \"arm-linux-gnueabihf-gcc\"</code></p> <ol> <li>Enable <code>armhf</code> in the package manager:</li> </ol> <p><code>sh    sudo dpkg --add-architecture armhf</code></p> <ol> <li>Update the package sources by opening the file <code>/etc/apt/sources.list</code> and adding the following lines (Note: This step can be ignored in Debian):</li> </ol> <p>```plaintext    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-</p> <p>ports jammy main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-backports main restricted universe multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security multiverse    ```</p> <ol> <li>Verify that the <code>armhf</code> architecture is still enabled:</li> </ol> <p><code>sh    sudo dpkg --add-architecture armhf</code></p> <ol> <li>Update the package information:</li> </ol> <p><code>sh    sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</code></p> <ol> <li>Install <code>webkitgtk</code> for the ARM architecture:</li> </ol> <p><code>sh    sudo apt install libwebkit2gtk-4.0-dev:armhf</code></p> <ol> <li>Set the <code>PKG_CONFIG_SYSROOT_DIR</code> environment variable to tell <code>pkg-config</code> where to find the libraries for the ARM architecture:</li> </ol> <p><code>sh    export PKG_CONFIG_SYSROOT_DIR=/usr/arm-linux-gnueabihf/</code></p> <ol> <li> <p>Finally, build the Raspirus application for the Raspberry Pi:</p> <p><code>sh cargo tauri build --target armv7-unknown-linux-gnueabihf</code></p> </li> </ol>"},{"location":"developers/cross-compile/#conclusion","title":"Conclusion","text":"<p>Once the cross-compilation process is complete, you will find the static website in the <code>out</code> folder. Please note that if you encounter any issues during the process, such as the inability to run the project, it can be safely ignored as you are likely not on a Raspberry Pi, and therefore, running it directly is not possible.</p> <p>Congratulations! You have successfully cross-compiled Raspirus for the Raspberry Pi.</p>"},{"location":"developers/frontend/","title":"Frontend","text":"<p>The frontend of the Raspirus app was planned using an external website called Figma. Although there have been some changes in styling and additional functions, the logical structure remains largely the same. Each screen in the app corresponds to a single page in Next.js. Additionally, the pop-ups in the original design have been replaced with ones from SweetAlertv2. You can explore the Figma project in the embedded iFrame below. If the iFrame doesn't load, you can access the project here.</p>"},{"location":"developers/frontend/#screenshots","title":"Screenshots","text":"<p>(Screenshots are missing in the provided content.)</p>"},{"location":"developers/frontend/#pages","title":"Pages","text":"<p>The entire project is structured into components and pages. The frontend of the app functions like a regular website, with routing and links between pages. There is a separate page for each important action in the app, such as scanning, settings, and information. All pages, except the scanning and home pages, have a button to return to the home page. In the case of this project, each page exists in duplicate due to an issue with the translation plugin. Therefore, the actual page resides inside the <code>[lang]</code> folder, while the pages outside of it are used for routing. It's important to note that there are special pages like <code>app.js</code> and <code>document.js</code> that have a specific structure. To learn more about these special pages, refer to the Next.js documentation on basic features/pages.</p>"},{"location":"developers/frontend/#components","title":"Components","text":"<p>Components are used to store repeated or cluttered code, helping keep the code of the pages clean and focused. Each component should have a single responsibility. For example, a component may display a single card on the settings page. Both components and pages are stored in separate directories at the root and can be imported. Components should be imported into pages, but not the other way around.</p>"},{"location":"developers/frontend/#localization","title":"Localization","text":"<p>The frontend of the app is also translated into different languages. The language files can be found in the <code>public</code> directory, with each language having its own folder containing a JSON file. The JSON files follow a key-value structure, where the keys need to be consistent across all language files, while the values are the translations. When translating, it's important to review the context and consider any potential changes. The app utilizes Next.js' i18n feature for localization, which works well but can be complicated to set up with Tauri. If you want to add new languages, be sure to specify it in your pull request or issue, as some code adjustments may be necessary. For example, updating the language display on the main page requires manual changes and is not automated. Here's an example of how localization works on the frontend:</p> <pre><code>Swal.fire(t(\"usb_list_error\"), t(\"usb_list_error_msg\"), \"error\");\n</code></pre> <p>In this case, a SweetAlert pop-up is displayed with a title and message. The important part is the <code>t(key)</code> function, which retrieves the translation associated with the given key from the JSON file.</p>"},{"location":"developers/frontend/#invoking-rust","title":"Invoking Rust","text":"<p>The frontend doesn't perform calculations itself, as that task is handled by the Rust backend. Rust is faster and has access to local files. To establish communication between the frontend and backend, Tauri is used. Tauri provides an API to call Rust functions and await results on the frontend, similar to a Promise. Here's an example:</p> <pre><code>invoke(\"list_usb_drives\", {})\n  .then((output) =&gt; {\n    setDictionary(JSON.parse(output));\n    setTimeout(() =&gt; {\n      refreshButton.classList.remove(styles.refreshStart);\n    }, 3000);\n  })\n  .catch((error) =&gt; {\n    console.error(error);\n    refreshButton.classList.remove(styles.refreshStart);\n    Swal.fire(t(\"usb_list_error\"), t(\"usb_list_error_msg\"), \"error\");\n  });\n</code></pre> <p>In this code snippet, the <code>invoke()</code> function from Tauri is used to call a Rust function, and then the frontend waits for the result or handles any potential errors.</p>"},{"location":"en/developers/","title":"Developers","text":"<p>The Raspirus project employs two distinct programming languages and frameworks: one for the frontend and one for the backend. The frontend utilizes JavaScript with the Next.js framework, while the backend is built with Rust. Communication between these languages is facilitated by the Tauri framework, enabling seamless integration of Rust functions in the frontend.</p>"},{"location":"en/developers/#technologies-used","title":"Technologies Used","text":"<ul> <li>NPM:   To achieve an aesthetically pleasing frontend, I explored native application development options initially. However, the customization capabilities fell short of my expectations. Consequently, I opted for a web-based frontend and selected Node.js over Deno due to my familiarity with Node.js.</li> <li>Next.js:   Next.js, a frontend framework, proved to be easy to implement and incredibly powerful once set up. The project extensively leverages Next.js's capability to export the website as static HTML, which is crucial for the functioning of Tauri. Additionally, Next.js optimizes the application by automatically eliminating unnecessary components, resulting in a lightweight and fast application. Navigation with Next.js is nearly instantaneous.</li> <li>Rust:   While C++ was my initial choice for the backend, my proficiency wasn't sufficient to develop the entire application in that language. I turned to Python, my preferred language and one in which I am proficient, for faster development. However, Python's speed limitations became a significant drawback. Fortunately, a friend helped rewrite the entire backend in Rust, boosting the application's speed by 100x. Rust's compilation-based approach and performance superiority over interpreted languages like Python made it an ideal choice. If you are interested in the previous Python implementation, you can refer to the dedicated repository.</li> <li>Tauri:   Tauri plays a vital role in this project by bridging the Rust backend with the JavaScript frontend. This allows us to have an elegant frontend with Next.js and an impressively fast backend with Rust. Furthermore, Tauri simplifies the compilation of the application into installers or binaries for different systems like Windows, Linux, or macOS, greatly enhancing the installation experience.</li> <li>SweetAlert2:   When presenting errors, warnings, or information to the user as pop-ups, the default JavaScript alert lacks visual appeal. SweetAlert2 significantly enhances the appearance of these pop-ups. It is easy to install and use. In our case, SweetAlert2 is mainly used for displaying errors or warnings, such as when the scanning process is abruptly interrupted.</li> <li>next-i18next:   Although the application contains minimal text and relies on icons and colors for clarity, we decided to incorporate translations. This is achieved using the Next.js plugin called i18next, which facilitates easy translation management through .JSON files.</li> <li>Crowdin:   Crowdin is a website that aids in translating open-source and private projects, and I am particularly grateful that it offers free pricing for open-source projects. Crowdin allows translators to focus solely on translations without the need to examine code. It also streamlines the translation synchronization process between Crowdin and GitHub.</li> <li>MkDocs:   MkDocs, a Python framework, is utilized to generate project documentation. In fact, this very translation you are reading was created using MkDocs. It is user-friendly and facilitates document structuring and integration with plugins like</li> </ul> <p>Crowdin. - Dependabot:   Dependabot, a built-in feature in GitHub repositories, ensures that dependencies are up to date by automatically checking for updates. This helps maintain an up-to-date application with the latest patches and functionality. By improving dependencies, the application's performance and efficiency can be enhanced. Moreover, Dependabot notifies users of any security vulnerabilities in the utilized dependencies or crates, ensuring the application's security. - GitHub:   GitHub was selected as the file hosting platform due to its popularity, user-friendly interface, and comprehensive feature set. Additionally, it offers free hosting. Although a company suggested hosting the project on their GitLab servers, GitHub's ease of use and collaboration capabilities prevailed over the complexities of utilizing a VPN to connect to a PC that connects to GitLab. GitHub offers numerous features, including project planning, milestones, issues, and actions. - CodeQL:   CodeQL, another powerful tool from GitHub, scans the project for vulnerabilities in the code. It detects issues like cross-site scripting, improper handling of passwords and secrets, and inefficient coding practices. CodeQL ensures a higher level of code reliability. - CodeCov:   Codecov, an external tool installable on GitHub, tracks test coverage. It provides insights into the effectiveness of written tests and their coverage across the entire project. Although testing the frontend is challenging as it often involves user interaction, testing the backend is feasible. Therefore, we integrated Codecov to monitor test coverage in our Rust backend.</p>"},{"location":"en/developers/#integration","title":"Integration","text":"<p>Raspirus is a self-contained application, operating solely within its environment. There are no external APIs for retrieving information, nor is the application designed for integration with other apps. The primary user interaction occurs via a touchscreen interface, eliminating the need for text input fields, which can be frustrating on low-quality touchscreens like the one found on a Raspberry Pi.</p> <p>Although API calls are made, they are internal to the application. For instance, in the <code>loading.js</code> file, we invoke the scanning function from the frontend to initiate the scanner in Rust:</p> <pre><code>const message = await invoke(\"start_scanner\", {\n    path: scan_path,\n    dbfile: db_location,\n    obfuscated: obfuscatedMode,\n});\n</code></pre> <p>The <code>start_scanner</code> function is called with the required parameters, and the resulting message is stored in the <code>message</code> constant. This basic Tauri API call enables seamless communication between the frontend and backend.</p> <p>To send data from the backend to the frontend, Tauri employs the signal principle:</p> <pre><code>fn calculate_progress(&amp;mut self, last_percentage: &amp;mut f64, file_size: u64) {\n    self.scanned_size += file_size;\n    let scanned_percentage = (self.scanned_size as f64 / self.folder_size as f64 * 100.0).round();\n    info!(\"Scanned: {}%\", scanned_percentage);\n    if scanned_percentage != *last_percentage {\n        self.tauri_window.emit_all(\"progress\", TauriEvent { message: scanned_percentage.to_string() }).unwrap();\n        *last_percentage = scanned_percentage;\n    }\n}\n</code></pre> <p>For further details on how this internal API system operates, refer to the official Tauri guide.</p>"},{"location":"en/developers/backend/","title":"Backend","text":"<p>In the backend of the Raspirus app, several components work together to provide the desired functionality. This section outlines the planning, database structure, scanner, and logging aspects of the backend.</p>"},{"location":"en/developers/backend/#planning","title":"Planning","text":"<p>The activity diagrams below illustrate the logical flow of the app. While the exact flow may evolve over time, these diagrams represent the initial planning of the app. The backend follows a relatively straightforward design, utilizing if statements and a for-each loop. The complexity lies in managing the database, scanning files, creating hashes, and communicating the results to the frontend through signal emissions.</p> <p>Activity Diagram:  </p>"},{"location":"en/developers/backend/#database","title":"Database","text":"<p>The database consists of a single large file with two main columns. This file is generated at runtime and can be updated through a button on the GUI. At the time of writing, the database file is approximately 4 GB in size and can take up to an hour to generate. The first column contains all signatures as primary keys, while the second column contains the corresponding file names extracted from the Virusshare database file names.</p>"},{"location":"en/developers/backend/#structure","title":"Structure","text":"<p>The database structure is as follows:</p> MD5 Hash FileNr .... .... 40610db6af6eaf2391b7a169e2540de9 00219 64a613db4aa368108e6d4c15ef7f6454 00219 .... ...."},{"location":"en/developers/backend/#initialization","title":"Initialization","text":"<p>The following Rust code in the <code>main.rs</code> file creates the database:</p> <pre><code>let mut use_db = \"signatures.db\".to_owned();\nmatch dbfile {\n    Some(fpath) =&gt; {\n        if Path::new(&amp;fpath).to_owned().exists() &amp;&amp; Path::new(&amp;fpath).to_owned().is_file() {\n            info!(\"Using specific DB path {}\", fpath);\n            use_db = fpath.to_owned();\n        } else {\n            info!(\"Falling back to default DB file (signatures.db)\");\n        }\n    }\n    None =&gt; {\n        info!(\"Path is None; Falling back to default DB file (signatures.db)\");\n    }\n};\n</code></pre> <p>If the specified <code>signatures.db</code> file doesn't exist, the code will attempt to create it and the necessary table. You can also provide your own file by placing it in the same folder as the executable. Just ensure that the table structure is the same.</p>"},{"location":"en/developers/backend/#scanner","title":"Scanner","text":"<p>The scanner class is the core function of the app. It takes a directory as a parameter and starts scanning it. It recursively scans all folders and files by hashing them and checking the hash in the database for matches.</p>"},{"location":"en/developers/backend/#ignoring-hashes-false-positives","title":"Ignoring Hashes (False Positives)","text":"<p>In the <code>file_scanner.rs</code> file, where the scanner is defined, there is an array that contains signatures to be ignored. Since Virusshare primarily adds hashes and rarely removes them, we need to handle filtering on the client-side. For example, if there is a hash for empty files, we added an exemption to prevent them from being flagged as dangerous:</p> <pre><code>let false_pos: Vec&lt;String&gt; = vec![\"7dea362b3fac8e00956a4952a3d4f474\".to_owned()];\n</code></pre>"},{"location":"en/developers/backend/#obfuscated-mode","title":"Obfuscated Mode","text":"<p>To address privacy concerns, the scanner offers an \"Obfuscated mode.\" When enabled, the app immediately fails upon finding a virus without scanning the entire folder</p> <p>. It outputs red or green depending on the security of the scan, without revealing the path and names of the detected files.</p>"},{"location":"en/developers/backend/#logging","title":"Logging","text":"<p>The app incorporates a logger that tracks issues or warnings during execution. However, the logger only functions in <code>dev</code> or <code>debug</code> mode. When packing the app into an executable, the logger is stripped away for improved performance. Efforts are underway to reintroduce logging functionality in the future.</p>"},{"location":"en/developers/cross-compile/","title":"How to Cross-Compile Raspirus for the Raspberry Pi","text":"<p>Note: The following guide explains how to cross-compile the Raspirus application from a Linux machine to run on a Raspberry Pi. Please ensure that you have a Linux machine with GLIBC compatible with your target Raspberry Pi.</p>"},{"location":"en/developers/cross-compile/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding with the cross-compilation process, ensure that you have the following:</p> <ul> <li>A Linux machine with GLIBC compatible with the target Raspberry Pi.</li> </ul>"},{"location":"en/developers/cross-compile/#initial-setup","title":"Initial Setup","text":"<p>To begin cross-compiling Raspirus, follow these initial setup steps to install Rust, Node.js, Tauri, and their dependencies:</p> <ol> <li>Update the Linux distribution:</li> </ol> <p><code>sh    sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</code></p> <ol> <li>Install Tauri system requirements by executing the following command:</li> </ol> <p><code>sh    sudo apt install libwebkit2gtk-4.0-dev \\        build-essential \\        curl \\        wget \\        libssl-dev \\        libgtk-3-dev \\        libayatana-appindicator3-dev \\        librsvg2-dev</code></p> <ol> <li>Install Rust by running the following command:</li> </ol> <p><code>sh    curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh</code></p> <p>Ensure that Rust is up-to-date:</p> <p><code>sh    rustup update</code></p> <ol> <li>Install Tauri using Cargo, the Rust package manager:</li> </ol> <p><code>sh    cargo install tauri-cli</code></p> <ol> <li> <p>Install Node.js using your preferred method. For example, on Windows WSL, you can follow this guide. The steps involve installing NVM (Node Version Manager) and then installing Node.js using NVM.</p> </li> <li> <p>Remove any existing <code>node_modules</code> directory from the project folder:</p> </li> </ol> <p><code>sh    sudo rm -rf node_modules</code></p> <ol> <li>Install the required Node.js modules:</li> </ol> <p><code>sh    npm install</code></p> <ol> <li>Important! If you are using Linux WSL, add the following dependency to the <code>Cargo.toml</code> file located in <code>&lt;project-root&gt;/src-tauri/</code>:</li> </ol> <p>In the <code>[dependencies]</code> section, add the following line:</p> <p><code>toml    openssl-sys = { version = \"0.9.66\", features = [\"vendored\"] }</code></p>"},{"location":"en/developers/cross-compile/#cross-compiling","title":"Cross-Compiling","text":"<p>The following steps explain how to compile Raspirus for the Raspberry Pi on an x86_64 Linux host:</p> <ol> <li>Install the Rust target for the Raspberry Pi:</li> </ol> <p><code>sh    rustup target add armv7-unknown-linux-gnueabihf</code></p> <ol> <li>Install the linker for ARM:</li> </ol> <p><code>sh    sudo apt install gcc-arm-linux-gnueabihf</code></p> <ol> <li>Open or create the file <code>.cargo/config.toml</code> in the project root directory and add the following:</li> </ol> <p><code>toml    [target.armv7-unknown-linux-gnueabihf]    linker = \"arm-linux-gnueabihf-gcc\"</code></p> <ol> <li>Enable <code>armhf</code> in the package manager:</li> </ol> <p><code>sh    sudo dpkg --add-architecture armhf</code></p> <ol> <li>Update the package sources by opening the file <code>/etc/apt/sources.list</code> and adding the following lines (Note: This step can be ignored in Debian):</li> </ol> <p>```plaintext    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-</p> <p>ports jammy main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-backports main restricted universe multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security multiverse    ```</p> <ol> <li>Verify that the <code>armhf</code> architecture is still enabled:</li> </ol> <p><code>sh    sudo dpkg --add-architecture armhf</code></p> <ol> <li>Update the package information:</li> </ol> <p><code>sh    sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</code></p> <ol> <li>Install <code>webkitgtk</code> for the ARM architecture:</li> </ol> <p><code>sh    sudo apt install libwebkit2gtk-4.0-dev:armhf</code></p> <ol> <li>Set the <code>PKG_CONFIG_SYSROOT_DIR</code> environment variable to tell <code>pkg-config</code> where to find the libraries for the ARM architecture:</li> </ol> <p><code>sh    export PKG_CONFIG_SYSROOT_DIR=/usr/arm-linux-gnueabihf/</code></p> <ol> <li> <p>Finally, build the Raspirus application for the Raspberry Pi:</p> <p><code>sh cargo tauri build --target armv7-unknown-linux-gnueabihf</code></p> </li> </ol>"},{"location":"en/developers/cross-compile/#conclusion","title":"Conclusion","text":"<p>Once the cross-compilation process is complete, you will find the static website in the <code>out</code> folder. Please note that if you encounter any issues during the process, such as the inability to run the project, it can be safely ignored as you are likely not on a Raspberry Pi, and therefore, running it directly is not possible.</p> <p>Congratulations! You have successfully cross-compiled Raspirus for the Raspberry Pi.</p>"},{"location":"en/developers/frontend/","title":"Frontend","text":"<p>The frontend of the Raspirus app was planned using an external website called Figma. Although there have been some changes in styling and additional functions, the logical structure remains largely the same. Each screen in the app corresponds to a single page in Next.js. Additionally, the pop-ups in the original design have been replaced with ones from SweetAlertv2. You can explore the Figma project in the embedded iFrame below. If the iFrame doesn't load, you can access the project here.</p>"},{"location":"en/developers/frontend/#screenshots","title":"Screenshots","text":"<p>(Screenshots are missing in the provided content.)</p>"},{"location":"en/developers/frontend/#pages","title":"Pages","text":"<p>The entire project is structured into components and pages. The frontend of the app functions like a regular website, with routing and links between pages. There is a separate page for each important action in the app, such as scanning, settings, and information. All pages, except the scanning and home pages, have a button to return to the home page. In the case of this project, each page exists in duplicate due to an issue with the translation plugin. Therefore, the actual page resides inside the <code>[lang]</code> folder, while the pages outside of it are used for routing. It's important to note that there are special pages like <code>app.js</code> and <code>document.js</code> that have a specific structure. To learn more about these special pages, refer to the Next.js documentation on basic features/pages.</p>"},{"location":"en/developers/frontend/#components","title":"Components","text":"<p>Components are used to store repeated or cluttered code, helping keep the code of the pages clean and focused. Each component should have a single responsibility. For example, a component may display a single card on the settings page. Both components and pages are stored in separate directories at the root and can be imported. Components should be imported into pages, but not the other way around.</p>"},{"location":"en/developers/frontend/#localization","title":"Localization","text":"<p>The frontend of the app is also translated into different languages. The language files can be found in the <code>public</code> directory, with each language having its own folder containing a JSON file. The JSON files follow a key-value structure, where the keys need to be consistent across all language files, while the values are the translations. When translating, it's important to review the context and consider any potential changes. The app utilizes Next.js' i18n feature for localization, which works well but can be complicated to set up with Tauri. If you want to add new languages, be sure to specify it in your pull request or issue, as some code adjustments may be necessary. For example, updating the language display on the main page requires manual changes and is not automated. Here's an example of how localization works on the frontend:</p> <pre><code>Swal.fire(t(\"usb_list_error\"), t(\"usb_list_error_msg\"), \"error\");\n</code></pre> <p>In this case, a SweetAlert pop-up is displayed with a title and message. The important part is the <code>t(key)</code> function, which retrieves the translation associated with the given key from the JSON file.</p>"},{"location":"en/developers/frontend/#invoking-rust","title":"Invoking Rust","text":"<p>The frontend doesn't perform calculations itself, as that task is handled by the Rust backend. Rust is faster and has access to local files. To establish communication between the frontend and backend, Tauri is used. Tauri provides an API to call Rust functions and await results on the frontend, similar to a Promise. Here's an example:</p> <pre><code>invoke(\"list_usb_drives\", {})\n  .then((output) =&gt; {\n    setDictionary(JSON.parse(output));\n    setTimeout(() =&gt; {\n      refreshButton.classList.remove(styles.refreshStart);\n    }, 3000);\n  })\n  .catch((error) =&gt; {\n    console.error(error);\n    refreshButton.classList.remove(styles.refreshStart);\n    Swal.fire(t(\"usb_list_error\"), t(\"usb_list_error_msg\"), \"error\");\n  });\n</code></pre> <p>In this code snippet, the <code>invoke()</code> function from Tauri is used to call a Rust function, and then the frontend waits for the result or handles any potential errors.</p>"},{"location":"de/","title":"Zuhause","text":""},{"location":"de/#willkommen-bei-raspirus-docs","title":"Willkommen bei Raspirus Docs","text":""},{"location":"de/#inhalte","title":"Inhalte:","text":"<ul> <li>Einf\u00fchrung</li> <li>Installation</li> <li>Anleitungen</li> <li>FAQ</li> <li>Nutzung und Diagramme</li> <li>Entwicklerbereich<ul> <li>Frontend (Next.JS)</li> <li>Backend (Rost)</li> </ul> </li> <li>Mitwirken<ul> <li>Coding</li> <li>\u00dcbersetzungen</li> </ul> </li> </ul>"},{"location":"de/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Dieses Projektarchiv enth\u00e4lt die gesamte Dokumentation des Raspirus Projekts. Sie befindet sich derzeit in der Entwicklung und daher nicht zu zuverl\u00e4ssig.</p>"},{"location":"de/faq/","title":"FAQ","text":""},{"location":"de/faq/#wie-generiere-ich-die-dokumentation-fur-dieses-projektarchiv","title":"Wie generiere ich die Dokumentation f\u00fcr dieses Projektarchiv?","text":"<p>You can find the generated documentation in the rust folder and in case you want to generate your own, you can do so by using the <code>cargo doc</code> command. Hier sind einige Parameter, die Sie mit ihm verwenden k\u00f6nnen: - <code>--no-deps</code>: Ignoriert Abh\u00e4ngigkeiten, dokumentiert nur den Code selbst - <code>--release</code>: Es ist im Allgemeinen besser als ein Debug - <code>--target-dir</code>: Where to output the docs All together, the command might look something like this: \\   <code>cargo doc --no-deps --release --target-dir=/docs/generated/</code></p>"},{"location":"de/faq/#wie-kann-ich-in-vscode-einen-rust-analyzer-einrichten-der-in-einer-nicht-standardmaigen-verzeichnisstruktur-arbeitet","title":"Wie kann ich in VSCode einen Rust Analyzer einrichten, der in einer nicht-standardm\u00e4\u00dfigen Verzeichnisstruktur arbeitet?","text":"<p>Das Rust Analyzer Plugin in Visual Studio Code versucht nach einer Cargo.toml Datei im aktuellen Verzeichnis oder \u00fcbergeordnetem Verzeichnis zu suchen. But since we packed the entire application in the <code>app</code> directory, it's unable to find the file and therefore might not work. This is a big lost, as it doesn't tell you if your Rust files have correct syntax or not. Um dieses Problem zu l\u00f6sen, k\u00f6nnen Sie dem Plugin eine Option hinzuf\u00fcgen und den Speicherort Ihrer Cargo.toml Datei angeben. As stated in this comment, you need to add the following lines to the end of your plugin settings' JSON. Danach m\u00fcssen Sie auch den Analyzer neu starten, damit die \u00c4nderung wirksam wird.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/matklad/tmp/hello/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"de/faq/#weitere-demnachst","title":"Weitere demn\u00e4chst","text":"<p>...</p>"},{"location":"de/guides/","title":"Anleitungen","text":""},{"location":"de/guides/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/guides/#notizen","title":"Notizen","text":""},{"location":"de/guides/#export-in-pdf","title":"Export in PDF:","text":"<ul> <li>Folgen Sie den Anweisungen f\u00fcr Ihr Betriebssystem hier: https://github.com/orzih/mkdocs-with-pdf#requirements</li> <li>Installieren Sie alle Abh\u00e4ngigkeiten mit Pip mit <code>pip install -r requirements.txt</code></li> <li><code>mkdocs build</code> ausf\u00fchren</li> <li>PDF befindet sich in site/pdf/document.pdf</li> </ul>"},{"location":"de/guides/#ubersetzungen","title":"\u00dcbersetzungen","text":"<ul> <li>Link: https://github.com/ultrabug/mkdocs-static-i18n</li> </ul>"},{"location":"de/installation/","title":"Installation","text":"<p>Diese Anleitung hilft Ihnen beim Aufbau des Projekts auf Ihrem eigenen Rechner.</p>"},{"location":"de/installation/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ul> <li>Einf\u00fchrung</li> <li>Einschr\u00e4nkungen</li> <li>Step-by-step guide</li> <li>1. Repository herunterladen</li> <li>2. Rust installieren</li> <li>3. Install NPM</li> <li>4. Next.js installieren</li> <li>5. Tauri installieren</li> <li>6. Projektabh\u00e4ngigkeiten installieren</li> <li> <p>7. Projekt erstellen</p> </li> <li> <p>Conclusion https://github.com/Raspirus/Raspirus/releases</p> </li> </ul>"},{"location":"de/installation/#einfuhrung","title":"Einf\u00fchrung","text":"<p>For people that just want a working app, they can just head over to the Release page and download the executable for the correct platform. But if you are on a different Linux distribution, unsupported OS, or just want to compile the project on your own, this step-by-step guide will guide you.</p>"},{"location":"de/installation/#einschrankungen","title":"Einschr\u00e4nkungen","text":"<ul> <li>Glibc kann unter Linux Probleme verursachen: https://tauri.app/v1/guides/building/linux#limitations</li> <li> <p>You need to use 64-bit systems, else the app might crash because it's using memory improvements that only work there</p> </li> <li> <p>The app is meant to be run as a \"I'm the only app running on this system\" app. This is important regarding RAM usage, because if you have much RAM, it will use much RAM. And if you, for some reason, try to limit the initially available RAM, the app might crash because it doesn't have the promised amount of RAM. (A future version might have a toggle for this)</p> </li> </ul>"},{"location":"de/installation/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Bitte lesen Sie die ganze Anleitung einmal, bevor Sie jeden Schritt ausf\u00fchren!</p>"},{"location":"de/installation/#1-repository-herunterladen","title":"1. Repository herunterladen","text":"<p>Dieser Schritt ist sehr einfach, einfach das ganze Projektarchiv herunterladen, indem Sie auf die gr\u00fcne Schaltfl\u00e4che auf der Homepage dieses Projektarchivs klicken. Optional k\u00f6nnen Sie auch den f\u00fcr eine Ver\u00f6ffentlichung spezifischen Code herunterladen, indem Sie die Release-Seite besuchen und die <code>.zip</code> Datei in den Assets herunterladen. Eine weitere Sache, die Sie vielleicht tun m\u00f6chten, ist dieses Projektarchiv klonen</p>"},{"location":"de/installation/#2-rust-installieren","title":"2. Rust installieren","text":"<p>Eine der Voraussetzungen, um das Projekt zu kompilieren, ist die Installation von Rst. Also make sure that your Rust installation is up-to-date with the command <code>rustup update</code>. You can check if you have Rust installed on your machine with the command <code>rustc --version</code>, if this command fails, head over to the Rust website and follow the instructions for your OS.</p>"},{"location":"de/installation/#3-install-npm","title":"3. Install NPM","text":"<p>NPM wird ben\u00f6tigt, da das Frontend der App auf JavaScript funktioniert und im Grunde eine Webseite ist. Um zu \u00fcberpr\u00fcfen, ob Node.js bereits installiert ist, f\u00fchren Sie die Befehle <code>node -v</code> und <code>npm -v</code> aus. Wenn einer von ihnen fehlschl\u00e4gt, oder Sie feststellen, dass Sie eine \u00e4ltere Version haben auf der NPM-Website installieren, um die neueste Version f\u00fcr Ihr Betriebssystem zu installieren. Wenn du ein WSL verwendest, k\u00f6nnte diese Anleitung f\u00fcr dich n\u00fctzlich sein.</p>"},{"location":"de/installation/#4-nextjs-installieren","title":"4. Next.js installieren","text":"<p>Das Frontend basiert auf JavaScript mit dem bekannten Framework Next.js, es macht die Website-Entwicklung schneller und effizienter. Sie m\u00fcssen auch dieses Tool installieren, um die Anwendung erstellen zu k\u00f6nnen. Aber keine Sorge, Sie k\u00f6nnen dies einfach mit NPM: <code>npm installieren next@latest react@latest react-dom@latest eslint-config-next@latest</code>. Dies wird Next.js, React (die Next.js basiert darauf) und ESLink installieren. Mehr \u00fcber den Installationsprozess erfahren Sie hier.</p>"},{"location":"de/installation/#5-tauri-installieren","title":"5. Tauri installieren","text":"<p>Tauri ist das Framework, das das Ruster Backend mit dem Next.js Frontend verbindet. Es ist ein Open-Source-Projekt von sehr freundlichen und gastfreundlichen Menschen. Unfortunately, installing Tauri is not as straightforward as other processes. Es ist sehr OS abh\u00e4ngig und Sie werden daher sicherstellen, dass Sie die Voraussetzungen vor dem Start erf\u00fcllen. Danach k\u00f6nnen Sie Tauri-cli installieren: <code>Fracht installiert Tauri-cli</code>. Sie k\u00f6nnten auch NPM verwenden, um es zu installieren, aber wir werden haupts\u00e4chlich mit Fracht in dieser kurzen Anleitung arbeiten. Schau dir in seinem FAQ-Bereich an, um zu erfahren, warum NPM f\u00fcr dich vielleicht besser ist.</p>"},{"location":"de/installation/#6-projektabhangigkeiten-installieren","title":"6. Projektabh\u00e4ngigkeiten installieren","text":"<p>Zun\u00e4chst werden wir die Knotenmodule installieren. Um dies zu tun, gehen Sie in das Verzeichnis, das den gesamten Raspirus-Code enth\u00e4lt. \u00d6ffnen Sie das <code>App</code> Verzeichnis, \u00f6ffnen Sie ein Terminal an diesem Ort und f\u00fchren Sie den Befehl <code>npm install</code> aus. Dies kann eine Weile dauern, aber es wird alle notwendigen Module herunterladen. Warning!: On WSL you might get an <code>OpenSSL is missing</code> error, to fix this you need to edit the file <code>app/src-tauri/Cargo.toml</code> and add the following line: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code> in the <code>[dependencies]</code> section.</p>"},{"location":"de/installation/#7-projekt-erstellen","title":"7. Projekt erstellen","text":"<p>Bevor Sie das Projekt komplett erstellen k\u00f6nnen, gibt es noch eine Sache, die Sie vielleicht \u00fcberpr\u00fcfen m\u00f6chten. To make sure that the Rust part of the project works fine, open the folder <code>app/src-tauri/</code> and execute the command <code>cargo build</code>. Wenn dieser Befehl erfolgreich ist, k\u00f6nnen Sie zum <code>app/</code> Verzeichnis zur\u00fcckkehren. Wenn dieser Befehl fehlschl\u00e4gt, \u00f6ffnen Sie bitte ein Problem in diesem Projektarchiv mit so vielen Informationen wie m\u00f6glich. Wenn alles gut gelaufen ist, befinden Sie sich jetzt im <code>App</code> Verzeichnis, und Sie k\u00f6nnen sicher den Befehl <code>cargo tauri build</code> ausf\u00fchren. Dieser Befehl erstellt die gesamte Anwendung und zeigt am Ende des Prozesses einen Pfad an, der Ihnen zeigt, wo sich die ausf\u00fchrbare Datei befindet. Standardm\u00e4\u00dfig sollten Sie es im <code>app\\src-tauri\\target\\release</code> Ordner finden k\u00f6nnen.</p>"},{"location":"de/installation/#schlussfolgerung","title":"Schlussfolgerung","text":"<p>Diese Anwendung ist im Grunde eine Website, die mit einigen Rust Code verbunden und mit dem Tauri Framework verpackt ist. Es wird daher ein grafisches Overlay ben\u00f6tigen, um die Website zu starten und anzuzeigen. Dieses Projekt befindet sich in st\u00e4ndiger Entwicklung und wenn Sie etwas Ungew\u00f6hnliches finden, haben Sie einige gute Ideen oder finden Sie einige Fehler, haben Sie keine Angst, ein Problem auf diesem Repository zu \u00f6ffnen und ich werde Ihnen gerne helfen.</p>"},{"location":"de/usage/","title":"Auslastung","text":""},{"location":"de/usage/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/contributing/","title":"Beitr\u00e4ge","text":"<p>Dieses Projekt ist komplett Open-Source und w\u00e4re ohne Ihre Hilfe nicht m\u00f6glich. Every contribution even if just a little can help a lot. Opening an issue if you find a bug, fixing the bug by opening a pull-request, adding translations, adding features and much more are all types of contributions that help the project go forward.</p>"},{"location":"de/contributing/#ubersetzungen","title":"\u00dcbersetzungen","text":"<p>The app itself is made with user-friendliness in mind and therefore doesn't have much text to translate as we want the experience to be fast without slowing down the user by forcing him/her to read lots of stuff. Nonetheless, this project still needs a lot of translators. Foremost we need translators for the docs that you are reading right now, but the app also needs translators. \u00dcbersetzungen helfen die Benutzererfahrung zu verbessern und das Projekt breiter zug\u00e4nglich zu machen. You can find out more on the dedicated page.</p>"},{"location":"de/contributing/#coding","title":"Coding","text":"<p>Die App wird haupts\u00e4chlich aus zwei Programmiersprachen gebaut: Rust und JavaScript. JavaScript is used for the frontend to build a website using the Next.JS framework and make the app look nicer and be cross-platform. The backend on the other side is written in Rust because we value speed a lot when scanning files and therefore need a fast language. To make the two communicate we use the Tauri framework. Tauri ist ein in Rust geschriebenes Open-Source-Framework, ganz neu in seinem Bereich. In Zukunft gibt es auch einen Plan, einen Python-Installer hinzuzuf\u00fcgen. If you have knowledge in any of these fields you are more than welcome to contribute to the project. Sie k\u00f6nnen dieses Projekt nat\u00fcrlich auch als Beispiel verwenden, um Ihr eigenes Projekt zu erstellen.</p>"},{"location":"de/contributing/#sponsoring","title":"Sponsoring","text":"<p>KOMMT BALD</p>"},{"location":"de/contributing/coding/","title":"Code","text":""},{"location":"de/contributing/coding/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/contributing/translations/","title":"\u00dcbersetzungen","text":"<p>\u00dcbersetzungen sind sehr wichtig und k\u00f6nnen anderen Menschen helfen, die App einfacher zu verstehen und sie umfassender zur Verf\u00fcgung zu stellen. If you know a language outside of English and would like to add your translations you can do so in two ways: The first one is to translate the documentation, the second one is to translate the frontend strings.</p>"},{"location":"de/contributing/translations/#code-wird-ubersetzt","title":"Code wird \u00fcbersetzt","text":"<p>Es handelt sich um eine laufende Arbeit, die jedoch im Wesentlichen auf eine von zwei m\u00f6glichen Wegen erfolgen wird:</p>"},{"location":"de/contributing/translations/#ubersetzungsdatei","title":"\u00dcbersetzungsdatei","text":"<p>Es gibt eine \u00dcbersetzungsdatei im JSON-Format f\u00fcr jede einzelne Sprache. So the app would load the strings it needs from that file. This is a bit easier to implement for the developers, but not very efficient or great for translators, as it involves forking the repository.</p>"},{"location":"de/contributing/translations/#ubersetzungsdienst","title":"\u00dcbersetzungsdienst","text":"<p>Wir verwenden einen externen \u00dcbersetzungsdienst, um das Projekt zu \u00fcbersetzen. This option would allow translators to just translate the given strings and have an overview of how much has been translated and what still needs to be translated. Dies w\u00e4re die bevorzugte Option, aber die Kehrseite ist das Setup f\u00fcr diese Option. Since we don't know which service to use yet, this option will be added in the future when we have more concrete ideas and hopefully a bigger team. Wir werden wahrscheinlich Crowdin verwenden</p>"},{"location":"de/contributing/translations/#ubersetzungen-von-docs","title":"\u00dcbersetzungen von Docs","text":"<p>The docs you are reading right now also need translations and will require a much bigger effort than translating strings used on the frontend. Die Dokumentation ist ziemlich gro\u00df und kann daher einige Zeit in Anspruch nehmen, um zu \u00fcbersetzen. Als obige Option k\u00f6nnten wir den Service auch hier nutzen, aber das wird in Zukunft hinzugef\u00fcgt werden. If you want to start adding translations right away, I would suggest to do the following:</p> <ol> <li>Fork this repository: You can follow a guide online on how to do it properly.</li> <li>Enter the <code>docs</code> folder and, if the language you want to translate doesn't exist yet, add a new directory whose name is the name of the language you want to write translations for. For example, it would be <code>it</code> for italian, <code>de</code> for german and so on.</li> <li>Then change to that directory and edit the Markdown files inside that directory. Make sure you keep the original folder structure.</li> <li>Nachdem Sie die Bearbeitung abgeschlossen haben, speichern Sie Ihre Dateien und laden sie auf GitHub in Ihren Fork hoch. Mache einen GitHub Commit</li> <li>Jetzt k\u00f6nnen Sie eine Pull-Request in das urspr\u00fcngliche Projektarchiv \u00f6ffnen und verlangen, dass Ihre \u00c4nderungen dem Hauptprojekt hinzugef\u00fcgt werden.</li> <li>Jemand des Teams wird die \u00dcbersetzungen pr\u00fcfen und wenn akzeptiert, diese dem Hauptprojekt hinzuf\u00fcgen.</li> </ol> <p>In the future we hopefully have an external service that handles all this for you, so that you can focus on your translations without distractions. Wir werden wahrscheinlich Crowdin verwenden.</p>"},{"location":"de/developers/","title":"Entwickler","text":"<p>Das Raspirus-Projekt verwendet haupts\u00e4chlich zwei verschiedene Programmiersprachen und Frameworks. Eine f\u00fcr das Backend und eine f\u00fcr das Backend und eine f\u00fcr das Frontend. \\ Das Frontend wird unter Verwendung des Next.JS Frameworks in JavaScript geschrieben. Das Backend auf der anderen Seite ist in Rust geschrieben. The communication between these two programming languages is made using the Tauri framework. Using this framework one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"de/developers/backend/","title":"Backend","text":""},{"location":"de/developers/backend/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/developers/frontend/","title":"Frontend","text":""},{"location":"de/developers/frontend/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/developers/cross-compile/","title":"How to Cross-Compile Raspirus for the Raspberry Pi","text":"<p>Note: The following guide explains how to cross-compile the Raspirus application from a Linux machine to run on a Raspberry Pi. Please ensure that you have a Linux machine with GLIBC compatible with your target Raspberry Pi.</p>"},{"location":"de/developers/cross-compile/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding with the cross-compilation process, ensure that you have the following:</p> <ul> <li>A Linux machine with GLIBC compatible with the target Raspberry Pi.</li> </ul>"},{"location":"de/developers/cross-compile/#initial-setup","title":"Initial Setup","text":"<p>To begin cross-compiling Raspirus, follow these initial setup steps to install Rust, Node.js, Tauri, and their dependencies:</p> <ol> <li>Update the Linux distribution:</li> </ol> <p><code>sh    sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</code></p> <ol> <li>Install Tauri system requirements by executing the following command:</li> </ol> <p><code>sh    sudo apt install libwebkit2gtk-4.0-dev \\        build-essential \\        curl \\        wget \\        libssl-dev \\        libgtk-3-dev \\        libayatana-appindicator3-dev \\        librsvg2-dev</code></p> <ol> <li>Install Rust by running the following command:</li> </ol> <p><code>sh    curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh</code></p> <p>Ensure that Rust is up-to-date:</p> <p><code>sh    rustup update</code></p> <ol> <li>Install Tauri using Cargo, the Rust package manager:</li> </ol> <p><code>sh    cargo install tauri-cli</code></p> <ol> <li> <p>Install Node.js using your preferred method. For example, on Windows WSL, you can follow this guide. The steps involve installing NVM (Node Version Manager) and then installing Node.js using NVM.</p> </li> <li> <p>Remove any existing <code>node_modules</code> directory from the project folder:</p> </li> </ol> <p><code>sh    sudo rm -rf node_modules</code></p> <ol> <li>Install the required Node.js modules:</li> </ol> <p><code>sh    npm install</code></p> <ol> <li>Important! If you are using Linux WSL, add the following dependency to the <code>Cargo.toml</code> file located in <code>&lt;project-root&gt;/src-tauri/</code>:</li> </ol> <p>In the <code>[dependencies]</code> section, add the following line:</p> <p><code>toml    openssl-sys = { version = \"0.9.66\", features = [\"vendored\"] }</code></p>"},{"location":"de/developers/cross-compile/#cross-compiling","title":"Cross-Compiling","text":"<p>The following steps explain how to compile Raspirus for the Raspberry Pi on an x86_64 Linux host:</p> <ol> <li>Install the Rust target for the Raspberry Pi:</li> </ol> <p><code>sh    rustup target add armv7-unknown-linux-gnueabihf</code></p> <ol> <li>Install the linker for ARM:</li> </ol> <p><code>sh    sudo apt install gcc-arm-linux-gnueabihf</code></p> <ol> <li>Open or create the file <code>.cargo/config.toml</code> in the project root directory and add the following:</li> </ol> <p><code>toml    [target.armv7-unknown-linux-gnueabihf]    linker = \"arm-linux-gnueabihf-gcc\"</code></p> <ol> <li>Enable <code>armhf</code> in the package manager:</li> </ol> <p><code>sh    sudo dpkg --add-architecture armhf</code></p> <ol> <li>Update the package sources by opening the file <code>/etc/apt/sources.list</code> and adding the following lines (Note: This step can be ignored in Debian):</li> </ol> <p>```plaintext    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-</p> <p>ports jammy main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-backports main restricted universe multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security multiverse    ```</p> <ol> <li>Verify that the <code>armhf</code> architecture is still enabled:</li> </ol> <p><code>sh    sudo dpkg --add-architecture armhf</code></p> <ol> <li>Update the package information:</li> </ol> <p><code>sh    sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</code></p> <ol> <li>Install <code>webkitgtk</code> for the ARM architecture:</li> </ol> <p><code>sh    sudo apt install libwebkit2gtk-4.0-dev:armhf</code></p> <ol> <li>Set the <code>PKG_CONFIG_SYSROOT_DIR</code> environment variable to tell <code>pkg-config</code> where to find the libraries for the ARM architecture:</li> </ol> <p><code>sh    export PKG_CONFIG_SYSROOT_DIR=/usr/arm-linux-gnueabihf/</code></p> <ol> <li> <p>Finally, build the Raspirus application for the Raspberry Pi:</p> <p><code>sh cargo tauri build --target armv7-unknown-linux-gnueabihf</code></p> </li> </ol>"},{"location":"de/developers/cross-compile/#conclusion","title":"Conclusion","text":"<p>Once the cross-compilation process is complete, you will find the static website in the <code>out</code> folder. Please note that if you encounter any issues during the process, such as the inability to run the project, it can be safely ignored as you are likely not on a Raspberry Pi, and therefore, running it directly is not possible.</p> <p>Congratulations! You have successfully cross-compiled Raspirus for the Raspberry Pi.</p>"},{"location":"it/#benvenuti-a-raspirus-docs","title":"Benvenuti a Raspirus Docs","text":""},{"location":"it/#contenuto","title":"Contenuto:","text":"<ul> <li>Introduzione</li> <li>Installazione</li> <li>Guide</li> <li>FAQ</li> <li>Uso e diagrammi</li> <li>Sezione Sviluppatori<ul> <li>Frontend (Next.JS)</li> <li>Backend (Rust)</li> </ul> </li> <li>Contribuire<ul> <li>Coding</li> <li>Traduzioni</li> </ul> </li> </ul>"},{"location":"it/#introduzione","title":"Introduzione","text":"<p>Questo repository contiene tutta la documentazione del progetto Raspirus. Attualmente \u00e8 in fase di sviluppo e quindi non \u00e8 troppo affidabile.</p>"},{"location":"it/faq/","title":"FAQ","text":""},{"location":"it/faq/#come-posso-generare-la-documentazione-per-questo-repository","title":"Come posso generare la documentazione per questo repository?","text":"<p>You can find the generated documentation in the rust folder and in case you want to generate your own, you can do so by using the <code>cargo doc</code> command. Ecco alcuni parametri che potresti voler utilizzare con esso: - <code>--no-deps</code>: Ignora le dipendenze, documenta solo il codice stesso - <code>--release</code>: Generalmente \u00e8 meglio di un debug - <code>--target-dir</code>: Where to output the docs All together, the command might look something like this: \\   <code>cargo doc --no-deps --release --target-dir=/docs/generated/</code></p>"},{"location":"it/faq/#in-vscode-come-posso-impostare-lanalizzatore-di-rust-per-lavorare-nella-struttura-di-directory-non-standard","title":"In VSCode, come posso impostare l'analizzatore di Rust per lavorare nella struttura di directory non standard?","text":"<p>Il plugin dell'analizzatore Rust in Visual Studio Code cerca di cercare un file Cargo.toml nella directory corrente o nella directory principale. But since we packed the entire application in the <code>app</code> directory, it's unable to find the file and therefore might not work. This is a big lost, as it doesn't tell you if your Rust files have correct syntax or not. Per risolvere questo problema, \u00e8 possibile aggiungere un'opzione al plugin e specificare la posizione del file Cargo.toml. As stated in this comment, you need to add the following lines to the end of your plugin settings' JSON. In seguito, dovrai anche riavviare l'analizzatore per rendere effettiva la modifica.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/matklad/tmp/hello/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"it/faq/#piu-presto-in-arrivo","title":"Pi\u00f9 presto in arrivo","text":"<p>...</p>"},{"location":"it/guides/","title":"Guide","text":""},{"location":"it/guides/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/guides/#note","title":"Note","text":""},{"location":"it/guides/#esporta-in-pdf","title":"Esporta in PDF:","text":"<ul> <li>Segui le istruzioni per il tuo sistema operativo qui: https://github.com/orzih/mkdocs-with-pdf#requirements</li> <li>Installa tutte le dipendenze usando pip con <code>pip install -r requirements.txt</code></li> <li>Esegue <code>mkdocs build</code></li> <li>PDF si trova in sito/pdf/document.pdf</li> </ul>"},{"location":"it/guides/#traduzioni","title":"Traduzioni","text":"<ul> <li>Link: https://github.com/ultrabug/mkdocs-static-i18n</li> </ul>"},{"location":"it/installation/","title":"Installazione","text":"<p>Questa guida vi aiuter\u00e0 a costruire il progetto sulla vostra macchina.</p>"},{"location":"it/installation/#tabella-dei-contenuti","title":"Tabella dei contenuti","text":"<ul> <li>Introduzione</li> <li>Limitazioni</li> <li>Step-by-step guide</li> <li>1. Scarica il repository</li> <li>2. Installa Rust</li> <li>3. Install NPM</li> <li>4. Installa Next.js</li> <li>5. Installa Tauri</li> <li>6. Installa dipendenze progetto</li> <li> <p>7. Genera il progetto</p> </li> <li> <p>Conclusion https://github.com/Raspirus/Raspirus/releases</p> </li> </ul>"},{"location":"it/installation/#introduzione","title":"Introduzione","text":"<p>For people that just want a working app, they can just head over to the Release page and download the executable for the correct platform. But if you are on a different Linux distribution, unsupported OS, or just want to compile the project on your own, this step-by-step guide will guide you.</p>"},{"location":"it/installation/#limitazioni","title":"Limitazioni","text":"<ul> <li>Glibc pu\u00f2 causare problemi su Linux: https://tauri.app/v1/guides/building/linux#limitations</li> <li> <p>You need to use 64-bit systems, else the app might crash because it's using memory improvements that only work there</p> </li> <li> <p>The app is meant to be run as a \"I'm the only app running on this system\" app. This is important regarding RAM usage, because if you have much RAM, it will use much RAM. And if you, for some reason, try to limit the initially available RAM, the app might crash because it doesn't have the promised amount of RAM. (A future version might have a toggle for this)</p> </li> </ul>"},{"location":"it/installation/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Si prega di leggere l'intera guida una volta prima di iniziare ad eseguire ogni passaggio!</p>"},{"location":"it/installation/#1-scarica-il-repository","title":"1. Scarica il repository","text":"<p>Questo passaggio \u00e8 molto semplice, basta scaricare l'intero repository facendo clic sul pulsante verde sulla homepage di questo repository. Facoltativamente, \u00e8 anche possibile scaricare codice specifico per una Rilascio, visitando la pagina Rilasciare e scaricare il file <code>.zip</code> negli asset. Un'altra cosa che potresti voler fare \u00e8 clonare questo repository</p>"},{"location":"it/installation/#2-installa-rust","title":"2. Installa Rust","text":"<p>Uno dei requisiti per compilare il progetto \u00e8 quello di avere installato Rust. Also make sure that your Rust installation is up-to-date with the command <code>rustup update</code>. You can check if you have Rust installed on your machine with the command <code>rustc --version</code>, if this command fails, head over to the Rust website and follow the instructions for your OS.</p>"},{"location":"it/installation/#3-install-npm","title":"3. Install NPM","text":"<p>NPM \u00e8 necessario perch\u00e9 il frontend dell'applicazione funziona su JavaScript ed \u00e8 fondamentalmente un sito web. Per verificare se hai gi\u00e0 installato Node.js, prova ad eseguire i comandi: <code>node -v</code> e <code>npm -v</code>. Se qualcuno di loro fallisce, o si scopre che hai una versione pi\u00f9 vecchia, vai sul sito web NPM per installare l'ultima versione per il tuo sistema operativo. Se stai usando un WSL, questa guida potrebbe essere utile per te.</p>"},{"location":"it/installation/#4-installa-nextjs","title":"4. Installa Next.js","text":"<p>Il frontend \u00e8 costruito su JavaScript utilizzando un noto framework chiamato Next.js, rende lo sviluppo del sito Web pi\u00f9 veloce ed efficiente. Sar\u00e0 necessario installare anche questo strumento per essere in grado di costruire l'applicazione. Ma non ti preoccupare, puoi farlo facilmente con NPM: <code>npm install next@latest react@latest react-dom@latest eslint-config-next@latest</code>. Questo installer\u00e0 Next.js, React (che Next.js \u00e8 basato su) e ESLint. Puoi saperne di pi\u00f9 sul processo di installazione qui.</p>"},{"location":"it/installation/#5-installa-tauri","title":"5. Installa Tauri","text":"<p>Tauri \u00e8 il framework che collega il backend Rust con il frontend Next.js. Si tratta di un progetto open-source realizzato da persone molto cordiale e accogliente. Unfortunately, installing Tauri is not as straightforward as other processes. \u00c8 molto dipendente dal sistema operativo, e quindi ti assicurerai di soddisfare i Prerequisiti prima di iniziare. In seguito, \u00e8 possibile installare Tauri suing cargo: <code>cargo install tauri-cli</code>. Si potrebbe anche utilizzare NPM per installarlo, ma lavoreremo principalmente con il carico in questa breve guida. Scopri la loro sezione FAQ per sapere perch\u00e9 NPM potrebbe essere migliore per te.</p>"},{"location":"it/installation/#6-installa-dipendenze-progetto","title":"6. Installa dipendenze progetto","text":"<p>In primo luogo, installeremo i moduli del nodo. Per fare questo, vai alla directory che contiene tutto il codice Raspirus. Apri la directory <code>app</code> , apri un terminale in questa posizione ed esegui il comando: <code>npm install</code>. Questo potrebbe richiedere un po ', ma scaricher\u00e0 tutti i moduli necessari. Warning!: On WSL you might get an <code>OpenSSL is missing</code> error, to fix this you need to edit the file <code>app/src-tauri/Cargo.toml</code> and add the following line: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code> in the <code>[dependencies]</code> section.</p>"},{"location":"it/installation/#7-genera-il-progetto","title":"7. Genera il progetto","text":"<p>Prima di poter costruire completamente il progetto, c'\u00e8 ancora una cosa che potresti voler controllare. To make sure that the Rust part of the project works fine, open the folder <code>app/src-tauri/</code> and execute the command <code>cargo build</code>. Se questo comando ha successo, puoi tornare alla directory <code>app/</code>. Se questo comando fallisce, si prega di aprire un problema su questo repository con il maggior numero possibile di informazioni sull'errore. Se tutto \u00e8 andato bene, ora sei nella directory <code>app</code> , ed \u00e8 possibile eseguire in modo sicuro il comando <code>cargo tauri build</code>. Questo comando generer\u00e0 l'intera applicazione e mostrer\u00e0 un percorso alla fine del processo mostrandoti dove si trova l'eseguibile. Per impostazione predefinita, dovresti essere in grado di trovarlo nella cartella <code>app\\src-tauri\\target\\release</code>.</p>"},{"location":"it/installation/#conclusione","title":"Conclusione","text":"<p>Questa applicazione \u00e8 fondamentalmente un sito web collegato ad alcuni codici Rust e confezionato con il framework Tauri. Sar\u00e0 quindi necessaria una sovrapposizione grafica per avviare e visualizzare il sito web. Questo progetto \u00e8 in costante sviluppo e quindi, se si trova qualcosa di insolito, avere alcune buone idee o trovare alcuni errori, non abbiate paura di aprire un problema su questo repository e sar\u00f2 felice di aiutarvi.</p>"},{"location":"it/usage/","title":"Utilizzo","text":""},{"location":"it/usage/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/contributing/","title":"Contributi","text":"<p>Questo progetto \u00e8 completamente open-source e non sarebbe possibile senza il vostro aiuto. Every contribution even if just a little can help a lot. Opening an issue if you find a bug, fixing the bug by opening a pull-request, adding translations, adding features and much more are all types of contributions that help the project go forward.</p>"},{"location":"it/contributing/#traduzioni","title":"Traduzioni","text":"<p>The app itself is made with user-friendliness in mind and therefore doesn't have much text to translate as we want the experience to be fast without slowing down the user by forcing him/her to read lots of stuff. Nonetheless, this project still needs a lot of translators. Foremost we need translators for the docs that you are reading right now, but the app also needs translators. Le traduzioni aiutano a migliorare l'esperienza utente e a rendere il progetto pi\u00f9 ampiamente disponibile. You can find out more on the dedicated page.</p>"},{"location":"it/contributing/#coding","title":"Coding","text":"<p>L'app \u00e8 costruita utilizzando principalmente due linguaggi di programmazione: Rust e JavaScript. JavaScript is used for the frontend to build a website using the Next.JS framework and make the app look nicer and be cross-platform. The backend on the other side is written in Rust because we value speed a lot when scanning files and therefore need a fast language. To make the two communicate we use the Tauri framework. Tauri \u00e8 un framework open-source scritto in Rust, abbastanza nuovo nel suo campo. In futuro c'\u00e8 anche un piano per aggiungere un programma di installazione Python. If you have knowledge in any of these fields you are more than welcome to contribute to the project. Ovviamente puoi anche usare questo progetto come esempio per creare il tuo progetto.</p>"},{"location":"it/contributing/#sponsorizzazione","title":"Sponsorizzazione","text":"<p>COMANDO SUONO</p>"},{"location":"it/contributing/coding/","title":"Codice","text":""},{"location":"it/contributing/coding/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/contributing/translations/","title":"Traduzioni","text":"<p>Le traduzioni sono molto importanti e possono aiutare altre persone a capire l'app pi\u00f9 facile e renderla pi\u00f9 ampia. If you know a language outside of English and would like to add your translations you can do so in two ways: The first one is to translate the documentation, the second one is to translate the frontend strings.</p>"},{"location":"it/contributing/translations/#tradurre-il-codice","title":"Tradurre il codice","text":"<p>Si tratta di un lavoro in corso, ma essenzialmente sar\u00e0 realizzato in uno dei due modi possibili:</p>"},{"location":"it/contributing/translations/#file-di-traduzione","title":"File di traduzione","text":"<p>C'\u00e8 un file di traduzione in formato JSON per ogni lingua differente. So the app would load the strings it needs from that file. This is a bit easier to implement for the developers, but not very efficient or great for translators, as it involves forking the repository.</p>"},{"location":"it/contributing/translations/#servizio-di-traduzione","title":"Servizio di traduzione","text":"<p>Utilizziamo un servizio di traduzioni esterne per tradurre il progetto. This option would allow translators to just translate the given strings and have an overview of how much has been translated and what still needs to be translated. Questa sarebbe l'opzione preferita, ma il lato negativo \u00e8 la configurazione di questa opzione. Since we don't know which service to use yet, this option will be added in the future when we have more concrete ideas and hopefully a bigger team. Probabilmente useremo Crowdin</p>"},{"location":"it/contributing/translations/#tradurre-documenti","title":"Tradurre Documenti","text":"<p>The docs you are reading right now also need translations and will require a much bigger effort than translating strings used on the frontend. La documentazione \u00e8 abbastanza grande e pu\u00f2 quindi richiedere un bel po' di tempo per tradurre. Come opzione di cui sopra, potremmo utilizzare il servizio anche qui, ma questo sar\u00e0 aggiunto in futuro. If you want to start adding translations right away, I would suggest to do the following:</p> <ol> <li>Fork this repository: You can follow a guide online on how to do it properly.</li> <li>Enter the <code>docs</code> folder and, if the language you want to translate doesn't exist yet, add a new directory whose name is the name of the language you want to write translations for. For example, it would be <code>it</code> for italian, <code>de</code> for german and so on.</li> <li>Then change to that directory and edit the Markdown files inside that directory. Make sure you keep the original folder structure.</li> <li>Dopo aver completato la modifica, salvare i file e caricarli sul tuo fork su GitHub. Fondamentalmente fai un commit di GitHub</li> <li>Ora puoi aprire una pull-request al repository originale e richiedere che le tue modifiche vengano aggiunte al progetto principale.</li> <li>Qualcuno del team esaminer\u00e0 le traduzioni e, se accettato, le aggiunger\u00e0 al progetto principale.</li> </ol> <p>In the future we hopefully have an external service that handles all this for you, so that you can focus on your translations without distractions. Probabilmente useremo Crowdin.</p>"},{"location":"it/developers/","title":"Sviluppatori","text":"<p>Il progetto Raspirus utilizza principalmente due linguaggi di programmazione e quadri diversi. Uno per il backend e uno per il backend e uno per il frontend. \\ Il frontend \u00e8 scritto in JavaScript utilizzando il framework Next.JS. Il backend sull'altro lato \u00e8 scritto in Rust. The communication between these two programming languages is made using the Tauri framework. Using this framework one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"it/developers/backend/","title":"Backend","text":""},{"location":"it/developers/backend/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/developers/frontend/","title":"Frontend","text":""},{"location":"it/developers/frontend/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/developers/cross-compile/","title":"How to Cross-Compile Raspirus for the Raspberry Pi","text":"<p>Note: The following guide explains how to cross-compile the Raspirus application from a Linux machine to run on a Raspberry Pi. Please ensure that you have a Linux machine with GLIBC compatible with your target Raspberry Pi.</p>"},{"location":"it/developers/cross-compile/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding with the cross-compilation process, ensure that you have the following:</p> <ul> <li>A Linux machine with GLIBC compatible with the target Raspberry Pi.</li> </ul>"},{"location":"it/developers/cross-compile/#initial-setup","title":"Initial Setup","text":"<p>To begin cross-compiling Raspirus, follow these initial setup steps to install Rust, Node.js, Tauri, and their dependencies:</p> <ol> <li>Update the Linux distribution:</li> </ol> <p><code>sh    sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</code></p> <ol> <li>Install Tauri system requirements by executing the following command:</li> </ol> <p><code>sh    sudo apt install libwebkit2gtk-4.0-dev \\        build-essential \\        curl \\        wget \\        libssl-dev \\        libgtk-3-dev \\        libayatana-appindicator3-dev \\        librsvg2-dev</code></p> <ol> <li>Install Rust by running the following command:</li> </ol> <p><code>sh    curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh</code></p> <p>Ensure that Rust is up-to-date:</p> <p><code>sh    rustup update</code></p> <ol> <li>Install Tauri using Cargo, the Rust package manager:</li> </ol> <p><code>sh    cargo install tauri-cli</code></p> <ol> <li> <p>Install Node.js using your preferred method. For example, on Windows WSL, you can follow this guide. The steps involve installing NVM (Node Version Manager) and then installing Node.js using NVM.</p> </li> <li> <p>Remove any existing <code>node_modules</code> directory from the project folder:</p> </li> </ol> <p><code>sh    sudo rm -rf node_modules</code></p> <ol> <li>Install the required Node.js modules:</li> </ol> <p><code>sh    npm install</code></p> <ol> <li>Important! If you are using Linux WSL, add the following dependency to the <code>Cargo.toml</code> file located in <code>&lt;project-root&gt;/src-tauri/</code>:</li> </ol> <p>In the <code>[dependencies]</code> section, add the following line:</p> <p><code>toml    openssl-sys = { version = \"0.9.66\", features = [\"vendored\"] }</code></p>"},{"location":"it/developers/cross-compile/#cross-compiling","title":"Cross-Compiling","text":"<p>The following steps explain how to compile Raspirus for the Raspberry Pi on an x86_64 Linux host:</p> <ol> <li>Install the Rust target for the Raspberry Pi:</li> </ol> <p><code>sh    rustup target add armv7-unknown-linux-gnueabihf</code></p> <ol> <li>Install the linker for ARM:</li> </ol> <p><code>sh    sudo apt install gcc-arm-linux-gnueabihf</code></p> <ol> <li>Open or create the file <code>.cargo/config.toml</code> in the project root directory and add the following:</li> </ol> <p><code>toml    [target.armv7-unknown-linux-gnueabihf]    linker = \"arm-linux-gnueabihf-gcc\"</code></p> <ol> <li>Enable <code>armhf</code> in the package manager:</li> </ol> <p><code>sh    sudo dpkg --add-architecture armhf</code></p> <ol> <li>Update the package sources by opening the file <code>/etc/apt/sources.list</code> and adding the following lines (Note: This step can be ignored in Debian):</li> </ol> <p>```plaintext    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-</p> <p>ports jammy main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-backports main restricted universe multiverse    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security main restricted    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security universe    deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security multiverse    ```</p> <ol> <li>Verify that the <code>armhf</code> architecture is still enabled:</li> </ol> <p><code>sh    sudo dpkg --add-architecture armhf</code></p> <ol> <li>Update the package information:</li> </ol> <p><code>sh    sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</code></p> <ol> <li>Install <code>webkitgtk</code> for the ARM architecture:</li> </ol> <p><code>sh    sudo apt install libwebkit2gtk-4.0-dev:armhf</code></p> <ol> <li>Set the <code>PKG_CONFIG_SYSROOT_DIR</code> environment variable to tell <code>pkg-config</code> where to find the libraries for the ARM architecture:</li> </ol> <p><code>sh    export PKG_CONFIG_SYSROOT_DIR=/usr/arm-linux-gnueabihf/</code></p> <ol> <li> <p>Finally, build the Raspirus application for the Raspberry Pi:</p> <p><code>sh cargo tauri build --target armv7-unknown-linux-gnueabihf</code></p> </li> </ol>"},{"location":"it/developers/cross-compile/#conclusion","title":"Conclusion","text":"<p>Once the cross-compilation process is complete, you will find the static website in the <code>out</code> folder. Please note that if you encounter any issues during the process, such as the inability to run the project, it can be safely ignored as you are likely not on a Raspberry Pi, and therefore, running it directly is not possible.</p> <p>Congratulations! You have successfully cross-compiled Raspirus for the Raspberry Pi.</p>"}]}