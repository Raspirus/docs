{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-raspirus-docs","title":"Welcome to Raspirus Docs","text":""},{"location":"#contents","title":"Contents:","text":"<ul> <li>Introduction</li> <li>Installation</li> <li>Guides</li> <li>FAQ</li> <li>Usage and Diagrams</li> <li>Developers Section<ul> <li>Frontend (Next.js)</li> <li>Backend (Rust)</li> </ul> </li> <li>Contributing<ul> <li>Coding</li> <li>Translations</li> </ul> </li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>This repository contains all documentation of the Raspirus project. It is currently in development and therefore not too reliable.</p>"},{"location":"#related-projects","title":"Related projects","text":"<p>Raspirus is a simple virus scanner, and there are many similar projects out there. I will list a few of them I know and why I decided not to use them for my project, or why Raspirus is better.</p> <ul> <li>Clam AV: This program is an open-source Antivirus, but it can also be used like Raspirus to scan single files or folders. It surely is more accurate when it comes to search for viruses, but it is very resource intensive and a bit slow. Therefore, it is not suited for single-board computers like the Raspberry Pi, as it doesn't have enough RAM. Nonetheless, Clam AV is a great open-source tool.</li> <li>Windows Defender: This program from Windows doesn't just scan files and folders on-demand, but scans the entire system continuously. This slows down the entire system. Furthermore, it is also Windows-only, while Raspirus is cross-platform.</li> <li>Bitdefender: This is another great Antivirus software, but it comes with a cost. I think that security should be a must, not something you need to pay for. But if you are willing to pay a bit, this piece of software really has it all, and as far as I know it is even cross-platform.</li> </ul> <p>There surely are many others that I could compare here, but Raspirus is not aimed at beating other Antivirus software. Its aim is to do one thing, and do it as best as possible: Compare Hashes of a file with a list of signatures.</p> <ul> <li>This project is free and will always stay free. </li> <li>It is open-source, so you can look at the code and judge for yourself if you trust the app or not.</li> <li>Community helps grow the project, and many smart minds surely can achieve a lot if they work together</li> <li>Cross-platform as a standard: Raspirus should work everywhere</li> <li>Lightweight and fast, usable even on your Potato PC</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>In this page, we will answer your most asked questions. As more questions arise, we will expand this page to include more answers. This page is very useful if you encounter any errors during development or usage. Maybe your error can be easily fixed and doesn't require a bug report.</p>"},{"location":"faq/#what-is-the-icon-of-the-project","title":"What is the Icon of the project?","text":"<p> In case you didn't notice yet, this is the logo of the Raspirus app. It was generated with DALL-E and some creative image editing and merging. It should represent a red monster that eats viruses. His name is Stuart by the way, and don't worry, he is a very kind monster, except for when he is hungry, then you better feed him viruses. You can find more media and documents in the dedicated repository. You are free to use these images to create your own art and showcase them in the discussion boards</p>"},{"location":"faq/#how-do-i-generate-the-documentation-for-this-repository","title":"How do I generate the documentation for this repository?","text":"<p>You can find the generated documentation in the rust folder and in case you want to generate your own, you can do so by using the <code>cargo doc</code> command. Here are some parameters you might want to use with it: - <code>--no-deps</code>: Ignores dependencies, only documents the code itself - <code>--release</code>: It is generally better than a debug - <code>--target-dir</code>: Where to output the docs All together, the command might look something like this: \\   <code>cargo doc --no-deps --release --target-dir=/docs/generated/</code></p>"},{"location":"faq/#in-vs-code-how-do-i-set-up-rust-analyzer-to-work-in-non-standard-directory-structure","title":"In VS Code, how do I set up Rust analyzer to work in non-standard directory structure?","text":"<p>The Rust analyzer plugin in Visual Studio Code tries to search for a Cargo.toml file in the current directory, or parent directory. But since we packed the entire application in the <code>app</code> directory, it's unable to find the file and therefore might not work. This is a big lost, as it doesn't tell you if your Rust files have correct syntax or not. To solve this issue, you can add an option to the plugin and specify the location of your Cargo.toml file. As stated in this comment, you need to add the following lines to the end of your plugin settings' JSON. Afterward, you will also need to restart the Analyzer for the modification to take effect.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/matklad/tmp/hello/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"faq/#updating-database-crashes-app","title":"Updating database crashes app","text":"<p>On Windows, it seems like the app crashes when the user tries to update the database. We are aware of this issue and working to fix it. The issue arises because the function needs administrative privileges, which Windows isn't providing. To fix this issue for now, simply execute the app in administration mode, aka. With admin privileges. You can do so by right-clicking the app and clicking <code>Run as administrator</code>.</p>"},{"location":"guides/","title":"Guides","text":"<p>Here are some guides on how to export the docs to PDF format, or how to add translations to this project. If anything is missing, make sure to post a comment below and request a guide!</p>"},{"location":"guides/#export-to-pdf","title":"Export to PDF","text":"<p>This documentation can be exported in PDF format for offline sharing. The exported PDF has some issues with Images and iFrames, but the text is readable and can be shared. Here step by step: 1. Clone this repository, you can find instructions on how to it on GitHub 2. Install the requirements for the PDF conversion tool, you can find them for your OS here 3. Change to the cloned directory and install the required dependencies. Note: You will need Python3 and pip for this. You can install the dependencies with the command: <code>pip install -r requirements.txt</code> 4. Install mkdocs and run the build command: <code>mkdocs build</code> 5. If everything works as expected, your PDF should be located in <code>site/pdf/document.pdf</code></p>"},{"location":"guides/#translations","title":"Translations","text":"<ul> <li>Translate this document: https://github.com/ultrabug/mkdocs-static-i18n</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This guide will help you in building the project on your own machine.</p>"},{"location":"installation/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Limitations</li> <li>Step-by-step guide</li> <li>1. Download the repository</li> <li>2. Install Rust</li> <li>3. Install NPM</li> <li>4. Install Next.js</li> <li>5. Install Tauri</li> <li>6. Install project dependencies</li> <li> <p>7. Build the project</p> </li> <li> <p>Conclusion https://github.com/Raspirus/Raspirus/releases</p> </li> </ul>"},{"location":"installation/#introduction","title":"Introduction","text":"<p>For people that just want a working app, they can just head over to the Release page and download the executable for the correct platform. But if you are on a different Linux distribution, unsupported OS, or just want to compile the project on your own, this step-by-step guide will guide you.</p>"},{"location":"installation/#limitations","title":"Limitations","text":"<ul> <li>Glibc can cause problems on Linux: https://tauri.app/v1/guides/building/linux#limitations</li> <li> <p>You need to use 64-bit systems, else the app might crash because it's using memory improvements that only work there</p> </li> <li> <p>The app is meant to be run as a \"I'm the only app running on this system\" app. This is important regarding RAM usage, because if you have much RAM, it will use much RAM. And if you, for some reason, try to limit the initially available RAM, the app might crash because it doesn't have the promised amount of RAM. (A future version might have a toggle for this)</p> </li> </ul>"},{"location":"installation/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Please read the whole guide once before starting to execute each step!</p>"},{"location":"installation/#1-download-the-repository","title":"1. Download the repository","text":"<p>This step is very straightforward, just download the whole repository by clicking the green button on the homepage of this repository. Optionally, you can also download code specific to a Release by visiting the Release page and download the <code>.zip</code> file in the assets. Another thing you might want to do is clone this repository</p>"},{"location":"installation/#2-install-rust","title":"2. Install Rust","text":"<p>One of the requirements to compile the project is to have Rust installed. You can check if you have Rust installed on your machine with the command <code>rustc --version</code>, if this command fails, head over to the Rust website and follow the instructions for your OS. Also make sure that your Rust installation is up-to-date with the command <code>rustup update</code>.</p>"},{"location":"installation/#3-install-npm","title":"3. Install NPM","text":"<p>NPM is needed because the frontend of the app works on JavaScript and is basically a website. To check if you already have Node.js installed, try executing the commands: <code>node -v</code> and <code>npm -v</code>. If any of them fail, or you find out you have an older version, head over to the NPM Website to install the latest version for your OS. If you are using a WSL, this guide might be useful to you.</p>"},{"location":"installation/#4-install-nextjs","title":"4. Install Next.js","text":"<p>The frontend is built on JavaScript using a well-known framework named Next.js, it makes website development faster and more efficient. You will need to install this tool too to be able to build the application. But don't worry, you can do this easily with NPM: <code>npm install next@latest react@latest react-dom@latest eslint-config-next@latest</code>. This will install Next.js, React (which Next.js is based on) and ESLint. You can learn more about the installation process here.</p>"},{"location":"installation/#5-install-tauri","title":"5. Install Tauri","text":"<p>Tauri is the framework that connects the Rust backend with the Next.js frontend. It is an open-source project made by very friendly and welcoming people. Unfortunately, installing Tauri is not as straightforward as other processes. It is very OS dependent, and you will therefore make sure that you meet the Prerequisites before you start. Afterward, you can install Tauri suing cargo: <code>cargo install tauri-cli</code>. You could also use NPM to install it, but we will mainly work with cargo in this short guide. Check out their FAQ section to learn about why NPM might be better for you.</p>"},{"location":"installation/#6-install-project-dependencies","title":"6. Install project dependencies","text":"<p>Firstly, we will install the node modules. To do this, head over to the directory that contains all the Raspirus code. Open the <code>app</code> directory, open a terminal in this location and execute the command: <code>npm install</code>. This might take a while, but it will download all the necessary modules. Warning!: On WSL you might get an <code>OpenSSL is missing</code> error, to fix this you need to edit the file <code>app/src-tauri/Cargo.toml</code> and add the following line: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code> in the <code>[dependencies]</code> section.</p>"},{"location":"installation/#7-build-the-project","title":"7. Build the project","text":"<p>Before you can completely build the project, there is one more thing you might want to check. To make sure that the Rust part of the project works fine, open the folder <code>app/src-tauri/</code> and execute the command <code>cargo build</code>. If this command succeeds, you can go back to the <code>app/</code> directory. If this command fails, please open an issue on this repository with as much information about the error as possible. If everything went well, you are now in the <code>app</code> directory, and you can safely execute the command <code>cargo tauri build</code>. This command will build the entire application and display a path at the end of the process showing you where the executable is located. By default, you should be able to find it in the <code>app\\src-tauri\\target\\release</code> folder.</p>"},{"location":"installation/#conclusion","title":"Conclusion","text":"<p>This application is basically a website attached to some Rust code and packaged with the Tauri framework. It will therefore need a graphical overlay to start and display the website. This project is in constant development and therefore, if you find anything unusual, have some good ideas or find some errors, don't be afraid to open an issue on this repository and I will be happy to help you out.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#tutorial","title":"Tutorial","text":"<p>How to use this app. It is super easy</p>"},{"location":"usage/#case-study","title":"Case study","text":"<p>Here are some metrics of the app, how fast it is, how reliable and what it can actually do. It also describes how the app is intended to be used.</p>"},{"location":"usage/#spezifikation","title":"Spezifikation","text":"<ul> <li>App size: 5MB</li> <li>RAM usage: ~ 50MB</li> <li>Works offline, only requires connection to Internet to update the database file</li> </ul>"},{"location":"usage/#metrics","title":"Metrics","text":"<p>The speed in which the app is able to scan highly depends on three things: - The USB or Storage medium used - The CPU of the system the app runs on. - The size of the single files that need to be scanned</p> <p>For optimal scanning speed, you should use a modern storage medium with high read speeds, a modern CPU that is not overloaded with other apps and files that are low in size. It is faster to scan 100 files of 10GB than 1 file of 10GB. The reason being that the Hash funktion is faster on smaller files.</p> <p>For Raspberry Pis, don't look at RAM, as the app only requires a couple MB. Instead, look at CPU speed, as that's more important.</p>"},{"location":"usage/#application","title":"Application","text":"<p>The app was originally intended to use only on Raspberry Pis with a touchscreen. The Raspberry Pi with Linux on it is easy to setup and very secure. Most of the viruses target Windows PC, and therefore have no effect on Linux. Furthermore, if you add a battery to your Raspberry Pi and set the app in Kiosk mode, you can create some sort of Raspirus box that can be carried around and is focused on scanning USB sticks. Thanks to Tauri and it's cross-compilation feature, Raspirus is available for all major systems: macOS, Windows, Linux. The app is primarly being developed and tested on Windows and Debian Linux. You can find installation instructions in the Installation page.</p>"},{"location":"contributing/","title":"Index.md","text":""},{"location":"contributing/#contributing-to-raspirus","title":"Contributing to Raspirus","text":"<p>First off, thanks for taking the time to contribute! \u2764\ufe0f</p> <p>All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for all involved. The community looks forward to your contributions. \ud83c\udf89</p> <p>And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about: - Star the project - Tweet about it - Refer this project in your project's readme - Mention the project at local meetups and tell your friends/colleagues</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>I Have a Question</li> <li>I Want To Contribute</li> <li>Reporting Bugs</li> <li>Suggesting Enhancements</li> <li>Your First Code Contribution</li> <li>Improving The Documentation</li> <li>Adding translations</li> <li>Styleguides</li> <li>Commit Messages</li> <li>Join The Project Team</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and everyone participating in it is governed by the Raspirus Code of Conduct. By participating, you are expected to uphold this code. Please report unacceptable behaviour to demetzbenjamin@duck.com.</p>"},{"location":"contributing/#i-have-a-question","title":"I Have a Question","text":"<p>If you want to ask a question, we assume that you have read the available Documentation.</p> <p>Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.</p> <p>If you then still feel the need to ask a question and need clarification, we recommend the following:</p> <ul> <li>Open an Issue.</li> <li>Provide as much context as you can about what you're running into.</li> <li>Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant.</li> <li>If the question is about the docs, write a comment at the bottom of the said page.</li> </ul> <p>We will then take care of the issue as soon as possible.</p>"},{"location":"contributing/#i-want-to-contribute","title":"I Want To Contribute","text":""},{"location":"contributing/#legal-notice","title":"Legal Notice","text":"<p>When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project licence.</p>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":""},{"location":"contributing/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<p>A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.</p> <ul> <li>Make sure that you are using the latest version.</li> <li>Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation. If you are looking for support, you might want to check this section).</li> <li>To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker.</li> <li>Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue.</li> <li>Collect information about the bug:</li> <li>Stack trace (Traceback)</li> <li>OS, Platform and Version (Windows, Linux, macOS, x86, ARM)</li> <li>Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.</li> <li>Possibly your input and the output</li> <li>Can you reliably reproduce the issue? And can you also reproduce it with older versions?</li> </ul>"},{"location":"contributing/#how-do-i-submit-a-good-bug-report","title":"How Do I Submit a Good Bug Report?","text":"<p>You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to demetzbenjamin@duck.com.</p> <p>We use GitHub issues to track bugs and errors. If you run into an issue with the project:</p> <ul> <li>Open an Issue. (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)</li> <li>Explain the behaviour you would expect and the actual behaviour.</li> <li>Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.</li> <li>Provide the information you collected in the previous section.</li> </ul> <p>Once it's filed:</p> <ul> <li>The project team will label the issue accordingly.</li> <li>A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as <code>needs-repro</code>. Bugs with the <code>needs-repro</code> tag will not be addressed until they are reproduced.</li> <li>If the team is able to reproduce the issue, it will be marked <code>needs-fix</code>, as well as possibly other tags (such as <code>critical</code>), and the issue will be left to be implemented by someone.</li> </ul>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>This section guides you through submitting an enhancement suggestion for Raspirus, including completely new features and minor improvements to existing functionality. Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.</p>"},{"location":"contributing/#before-submitting-an-enhancement","title":"Before Submitting an Enhancement","text":"<ul> <li>Make sure that you are using the latest version.</li> <li>Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration.</li> <li>Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.</li> <li>Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.</li> </ul>"},{"location":"contributing/#how-do-i-submit-a-good-enhancement-suggestion","title":"How Do I Submit a Good Enhancement Suggestion?","text":"<p>Enhancement suggestions are tracked as GitHub issues.</p> <ul> <li>Use a clear and descriptive title for the issue to identify the suggestion.</li> <li>Provide a step-by-step description of the suggested enhancement in as many details as possible.</li> <li>Describe the current behaviour and explain which behaviour you expected to see instead and why. At this point you can also tell which alternatives do not work for you.</li> <li>You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. </li> <li>Explain why this enhancement would be useful to most Raspirus users. You may also want to point out the other projects that solved it better and which could serve as inspiration.</li> </ul>"},{"location":"contributing/#attribution","title":"Attribution","text":"<p>This guide is based on the contributing-gen. Make your own!</p>"},{"location":"contributing/CODE_OF_CONDUCT/","title":"Code of Conduct - Raspirus","text":""},{"location":"contributing/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"contributing/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behaviour that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologising to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behaviour include:</p> <ul> <li>The use of sexualised language or imagery, and sexual attention or advances</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contributing/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying and enforcing our standards of acceptable behaviour and will take appropriate and fair corrective action in response to any instances of unacceptable behaviour.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviours that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"contributing/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behaviour may be reported to the community leaders responsible for enforcement at demetzbenjamin@duck.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4 and 2.0, and was generated by contributing-gen.</p>"},{"location":"contributing/coding/","title":"Code","text":""},{"location":"contributing/coding/#coming-soon","title":"COMING SOON","text":""},{"location":"contributing/translations/","title":"Translations.md","text":""},{"location":"contributing/translations/#comments-true","title":"comments: true","text":""},{"location":"contributing/translations/#translations","title":"Translations","text":"<p>Translations are very important and can help other people understand the app easier and make it wider available. If you know a language outside of English and would like to add your translations, you can do so in two ways: The first one is to translate the documentation, the second one is to translate the frontend strings.</p>"},{"location":"contributing/translations/#translating-code","title":"Translating code","text":"<p>This is a work in progress, but essentially it will be done in one of two possible ways:</p>"},{"location":"contributing/translations/#translation-file","title":"Translation file","text":"<p>There is a translations file in JSON format for each different language. So the app would load the strings it needs from that file. This is a bit easier to implement for the developers, but not very efficient or great for translators, as it involves forking the repository.</p>"},{"location":"contributing/translations/#translation-service","title":"Translation service","text":"<p>We use an external translations service to translate the project. This option would allow translators to just translate the given strings and have an overview of how much has been translated and what still needs to be translated. This would be the preferred option, but the downside is the setup for this option. Since we don't know which service to use yet, this option will be added in the future when we have more concrete ideas and hopefully a bigger team. We will probably use Crowdin</p>"},{"location":"contributing/translations/#translating-docs","title":"Translating Docs","text":"<p>The docs you are reading right now also need translations and will require a much bigger effort than translating strings used on the frontend. The documentation is quite big and can therefore take quite some time to translate. As the option above, we could use the service here too, but that will be added in the future. If you want to start adding translations right away, I would suggest doing the following:</p> <ol> <li>Fork this repository: You can follow a guide online on how to do it properly.</li> <li>Enter the <code>docs</code> folder and, if the language you want to translate doesn't exist yet, add a new directory whose name is the name of the language you want to write translations for. For example, it would be <code>it</code> for Italian, <code>de</code> for German and so on.</li> <li>Then change to that directory and edit the Markdown files inside that directory. Make sure you keep the original folder structure.</li> <li>After you have finished editing, save your files and upload them to your fork on GitHub. Basically make a GitHub commit</li> <li>Now you can open a pull-request to the original repository and request that your changes get added to the main project.</li> <li>Someone of the team will review the translations and if accepted add them to the main project.</li> </ol> <p>In the future, we hopefully have an external service that handles all this for you, so that you can focus on your translations without distractions. We will probably use Crowdin.</p>"},{"location":"developers/","title":"Developers","text":"<p>The Raspirus project mainly uses two different programming languages and frameworks. One for the backend and one for the backend and one for the frontend. \\ The frontend is written in JavaScript using the Next.js framework. The backend on the other side is written in Rust. The communication between these two programming languages is made using the Tauri framework. Using this framework, one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"developers/#technologies-used","title":"Technologies used","text":"<ul> <li>NPM:     I wanted the frontend to be beautiful, and at first I tried creating an actual native application, but that just didn't have the customization I was searching for. Therefore, I decided to write a Web-frontend, and for that I could choose between Node.js or Deno. I ended up using Node.js as it's the one I am mostly familiar with.</li> <li>Next.js:     Next.js is a frontend framework that is fairly easy to implement, and once setup can be very powerful. The most useful feature used in this project is the export of the website in static HTML. This is essential for Tauri to function. Another advantage of Next.js is that it optimizes itself, by automatically stripping away everything unnecessary, this makes the app lightweight and fast. Navigation with Next.js is practically instant.</li> <li>Rust:     Rust was not my first choice for the backend. At first, I started with C++, but I was not skilled enough to create the entire app with that language, so I turned to Python. Python is way slower than C++, but it's my favorite language and the one I know best, so I was able to develop faster. Nonetheless, the lack of speed with Python was a big drawback. Luckily, a friend of mine helped me out and rewrote the entire backend in Rust, basically speeding the app up by 100x. What previously took a couple of minutes, now took mere seconds. Rust is a compiled language and faster than Python, which is an interpreted language. If you want to test the old Python system, there is an entire repository for that.</li> <li>Tauri:     Tauri plays a very important part in this project, as it is a framework that allows connecting the Rust backend to a JavaScript frontend. This essentially allowed us to have a beautiful frontend in Next.js and an impressively fast backend in Rust. Furthermore, Tauri compiles the application for different systems, like Windows, Linux or macOS by creating installers or binaries. This improved the installation of the app.</li> <li>SweetAlertv2:     When errors occur, or there are warnings and information to display as a pop-up to the user, the simple JavaScript alert just doesn't look that good. SweetAlert improves the look of these pop-ups by a lot. It's fairly easy to install and to use. In our case, it is mainly used to display errors or warnings, for example when the scanning process is suddenly interrupted.</li> <li>next-i18next:     The app doesn't have much text, and with the icons and colors it should be fairly simple to understand what you need to do. Nonetheless, we decided to add translations to the app. This is done using a Next.js plugin named i18next, that allows to translate the project easily with .JSON files.</li> <li>Crowdin:     Crowdin is a website that collects translations from users and helps translate open-source and private projects. I am especially grateful that for open-source projects, the price for this service is free. It is useful for translators to focus on translations, without the need to look at code. It also helps developers, as it automatically syncs new translations with GitHub and vice versa.</li> <li>MkDocs:     MkDocs is a Python framework used to create documentation for projects. In fact, it is the framework used to create this specific translation. It is really easy to use and makes structuralizing docs or integrating plugins like Crowdin fairly easily.</li> <li>Dependabot:     Dependabot comes with every GitHub repository, and can be activated fairly easily. Its job is to check dependencies for updates and therefore to keep the entire app up-to-date. This also ensures that the app has the latest patches and functions. By improving its dependencies, the app might become faster and more efficient. Furthermore, Dependabot also informs the user about Security vulnerabilities of used dependencies or crates, a very useful feature to maintain the app secure.</li> <li>GitHub:     GitHub has been chosen as the file hosting platform mainly because it is popular, easy to use and has everything needed. Plus it's free. A company also suggested hosting the project on their GitLab servers, but in the end the project remained on GitHub as it is easier to use and to collaborate than to use a VPN to connect to a PC that then connects to GitLab. GitHub also has a lot of features: Project planing, Milestones, Issues, Actions, ...</li> <li>CodeQL:     CodeQL is another powerful tool from GitHub. It scans the entire project and checks for vulnerabilities in the code. For example, if there is cross-site-scripting happening somewhere, or we are not hiding passwords and secrets correctly, or we are coding inefficiently. This is very useful, as it assures a certain reliability of the code.</li> <li>CodeCov:     Codecov is an external tool that can be installed on GitHub, and it tracks test coverage. It basically tells you how efficient the tests you just wrote actually are, and if they cover the entire project. Testing the frontend is hard, as we would likely need to test user interaction, but testing the backend is doable. Therefore, we set up Codecov to check our Rust backend for test coverage.</li> </ul>"},{"location":"developers/#integration","title":"Integration","text":"<p>Raspirus is a standalone app and everything happens inside the app. What I mean by this is that there are mo APIs for the outside to get information from, and the app is also not meant to be used by other apps. The main usage of the app is through a touchscreen, that's why there are no input fields where a user has to type text, as that is a quite frustrating experience on bad touchscreen, as the one from a Raspberry Pi.  Actually, there are API calls, but they happen inside the app. In fact, the Next.js frontend calls the backend through the Tauri API.</p> <p>For example, in the <code>loading.js</code> file, we call the scanning function from the frontend to tell Rust to start the scanner:</p> <pre><code>const message = await invoke(\"start_scanner\", {\n    path: scan_path,\n    dbfile: db_location,\n    obfuscated: obfuscatedMode,\n});\n</code></pre> <p>We basically start the <code>start_scanner</code> function and give it the needed parameters. Then we save the result in the <code>message</code> constant. This is a basic Tauri API call. </p> <p>To instead communicate from the backend back to the frontend, Tauri uses the principle of signals:</p> <pre><code>fn calculate_progress(&amp;mut self, last_percentage: &amp;mut f64, file_size: u64) {\n    self.scanned_size = self.scanned_size + file_size;\n    let scanned_percentage = (self.scanned_size as f64 / self.folder_size as f64 * 100.0).round();\n    info!(\"Scanned: {}%\", scanned_percentage);\n    if scanned_percentage != *last_percentage {\n        self.tauri_window.emit_all(\"progress\", TauriEvent {message: scanned_percentage.to_string()}).unwrap();\n        *last_percentage = scanned_percentage;\n    }\n}\n</code></pre> <p>If you want to know more about how this internal API system exactly works, you can refer to the official Tauri guide.</p>"},{"location":"developers/backend/","title":"Backend","text":""},{"location":"developers/backend/#planing","title":"Planing","text":"<p>  This diagram describes how the logical flow of the app work. The exact flow can change in the future, but this was the initial planing of the app. As you can see, it is rather simple with just a couple if statements and a for-each loop. The backend is actually not that hard to understand, the complicated part is the more in-depth part of how to manage the database, scan files, create the hash and most importantly, communicate the result to the frontend by emitting signals.</p>"},{"location":"developers/backend/#database","title":"Database","text":"<p>The Database consists of a single big file with mainly two columns. This file is generated at runtime and can be updated with a button on the GUI. At the time of writing, this file is approximately 4 GB in size and can take up to an hour to generate. The database contains in one column all signatures as a primary key, and in the second column the name of the file they got extracted from, based on the Virusshare database file names.</p>"},{"location":"developers/backend/#structure","title":"Structure","text":"<p>Here is how the database may look like:</p> MD5 Hash FileNr .... .... 40610db6af6eaf2391b7a169e2540de9 00219 64a613db4aa368108e6d4c15ef7f6454 00219 .... ...."},{"location":"developers/backend/#initialisation","title":"Initialisation","text":"<p>Here is the Rust code in the main.rs file that creates the Database:</p> <pre><code>let mut use_db = \"signatures.db\".to_owned();\nmatch dbfile {\n    Some(fpath) =&gt; {\n        if Path::new(&amp;fpath).to_owned().exists() &amp;&amp; Path::new(&amp;fpath).to_owned().is_file() {\n            info!(\"Using specific DB path {}\", fpath);\n            use_db = fpath.to_owned();\n        } else {\n            info!(\"Falling back to default DB file (signatures.db)\");\n        }\n    }\n    None =&gt; {\n        info!(\"Path is None; Falling back to default DB file (signatures.db)\");\n    }\n};\n</code></pre> <p>If the specified <code>signatures.db</code> file doesn't exist, it will automatically attempt to create on and even create the necessary table. You can technically also provide your own file, just put it in the same folder as the executable. Also make sure that the table is the same.</p>"},{"location":"developers/backend/#scanner","title":"Scanner","text":"<p>The scanner class is the main function of the entire app. It takes a directory as parameter and starts scanning it. It will scan all folders and files recursively by hashing it and checking the hash in the database.</p>"},{"location":"developers/backend/#ignoring-hashes-false-positives","title":"Ignoring hashes (false positives)","text":"<p>In the <code>file_scanner.rs</code> file, where the scanner is declared, we also have an Array that contains signatures that should be ignored. Virusshare is a databse where Hashes are mostly added, not removed, and therefore we need to do our filtering on the client-side. For example there was a hash for empty files, but in our opinion empty file should not be flagged as dangerous, so we added an excemption:</p> <pre><code>let false_pos: Vec&lt;String&gt; = vec![\"7dea362b3fac8e00956a4952a3d4f474\".to_owned()];\n</code></pre>"},{"location":"developers/backend/#obfuscated-mode","title":"Obfuscated mode","text":"<p>Sometimes, for privacy reasons, you might not want to display the path and names of the found files, therefore the scanner provides a so-called 'Obfuscated mode'. Setting this to true will make the app fail immediately as soon as it finds a vairus, without scanning the entire folder, and output red or green depending on the security of the scan.</p>"},{"location":"developers/backend/#logging","title":"Logging","text":"<p>The app also has a logger that keeps track of issues or warnings during the execution of the app. Sadly this only works in <code>dev</code> or <code>debug</code> mode. When packing ito an executable the logger is lost as it gets stripped away for better performance. We are nonetheless working on bringing it back to life in the future.</p>"},{"location":"developers/frontend/","title":"Frontend","text":""},{"location":"developers/frontend/#planing","title":"Planing","text":"<p>The planing of the Raspirus frontend happened on an external Website called Figma. The styling changed a bit and there are some more functions now, but the logical structure is roughly the same. Each screen you see is a single page on Next.js. Furthermore, the pop-ups have been replaced with ones from SweetAlertv2. You can explore the Figma project in the iFrame below, else if nothing is showing up, you can look at the project here.</p>"},{"location":"developers/frontend/#screenshots","title":"Screenshots","text":""},{"location":"developers/frontend/#pages","title":"Pages","text":"<p>The entire project is structurized in components and pages. The frontend is basically a normal website, so it has routing, links and so on. We have one page for each important action of the app. There is one for the scanning process, for the settings, for the informations, ... Pages link to each other and apart from the scanning and home page, they all have a button to return to the home-page. In our case we have all pages double, this has to do with an issue in the translation plugin. So now the actualy page resides inside the [lang] folder and the pages outside of it are simply used for routing. Note that there are some special pages, like the app.js and the document.js page that have a special structure. To learn more about them, visit the Next.js page about this topic</p>"},{"location":"developers/frontend/#components","title":"Components","text":"<p>Components are used to store repeated or cluttered code. This helps in keeping the code of the pages clean and move the focus of certain code outside of them. Each component should only fulfill a single task. For example it should display a single card in the settings page. Both components and pages are stored in different directories at root and can be imported. Only import components into pages, not the other way around.</p>"},{"location":"developers/frontend/#localizing","title":"Localizing","text":"<p>The frontend is also translated into different languages. The languages can be found in the public directory, where each langauge has its own folder with a json file. The JSON files are built on a key-value basis. The keys always need to be the same on all JSON files and the value gets translated. Make sure to look at the app before blindly translating, as some things might change depending of the context. For the translations, we used the Nextjs feature i18n, which works fine but is a bit complicated to setup with Tauri. If you want to add new languages, make sure to specify it in your pull-request or in the issue, as we also need tu update some of the code to cover the changes. For example we need to update the button on the main page to display the new language, this is not automatic. Here is how localizing looks like on the frontend:</p> <pre><code>Swal.fire(t(\"usb_list_error\"), t(\"usb_list_error_msg\"), \"error\");\n</code></pre> <p>In this case we are calling a SweetAlert with a title and a message. The important part is the <code>t(key)</code> function. The function will return the text associated with the given string key, if it is able to find it in the JSOn file.</p>"},{"location":"developers/frontend/#invoke-rust","title":"Invoke Rust","text":"<p>The frontend doesn't do any calculations, because that's what we have the Rust backend for. Rust is much faster, and also has the ability to actually access local files. But to let the frontend and the backend communicate with each other we need Tauri. Tauri offers us an API to call functions from Rust and wait for a result on the frontend. It basically works like a Promise. Here an example:</p> <pre><code>invoke(\"list_usb_drives\", {})\n  .then((output) =&gt; {\n    setDictionary(JSON.parse(output));\n    setTimeout(() =&gt; {\n      refreshButton.classList.remove(styles.refreshStart);\n    }, 3000);\n  })\n  .catch((error) =&gt; {\n    console.error(error);\n    refreshButton.classList.remove(styles.refreshStart);\n    Swal.fire(t(\"usb_list_error\"), t(\"usb_list_error_msg\"), \"error\");\n  });\n</code></pre> <p>As you can see, we use a Tauri function called <code>invoke()</code> that calls a Rust function and then awaits for it result or catches a possible error.</p>"},{"location":"en/developers/","title":"Developers","text":"<p>The Raspirus project mainly uses two different programming languages and frameworks. One for the backend and one for the backend and one for the frontend. \\ The frontend is written in JavaScript using the Next.js framework. The backend on the other side is written in Rust. The communication between these two programming languages is made using the Tauri framework. Using this framework, one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"en/developers/#technologies-used","title":"Technologies used","text":"<ul> <li>NPM:     I wanted the frontend to be beautiful, and at first I tried creating an actual native application, but that just didn't have the customization I was searching for. Therefore, I decided to write a Web-frontend, and for that I could choose between Node.js or Deno. I ended up using Node.js as it's the one I am mostly familiar with.</li> <li>Next.js:     Next.js is a frontend framework that is fairly easy to implement, and once setup can be very powerful. The most useful feature used in this project is the export of the website in static HTML. This is essential for Tauri to function. Another advantage of Next.js is that it optimizes itself, by automatically stripping away everything unnecessary, this makes the app lightweight and fast. Navigation with Next.js is practically instant.</li> <li>Rust:     Rust was not my first choice for the backend. At first, I started with C++, but I was not skilled enough to create the entire app with that language, so I turned to Python. Python is way slower than C++, but it's my favorite language and the one I know best, so I was able to develop faster. Nonetheless, the lack of speed with Python was a big drawback. Luckily, a friend of mine helped me out and rewrote the entire backend in Rust, basically speeding the app up by 100x. What previously took a couple of minutes, now took mere seconds. Rust is a compiled language and faster than Python, which is an interpreted language. If you want to test the old Python system, there is an entire repository for that.</li> <li>Tauri:     Tauri plays a very important part in this project, as it is a framework that allows connecting the Rust backend to a JavaScript frontend. This essentially allowed us to have a beautiful frontend in Next.js and an impressively fast backend in Rust. Furthermore, Tauri compiles the application for different systems, like Windows, Linux or macOS by creating installers or binaries. This improved the installation of the app.</li> <li>SweetAlertv2:     When errors occur, or there are warnings and information to display as a pop-up to the user, the simple JavaScript alert just doesn't look that good. SweetAlert improves the look of these pop-ups by a lot. It's fairly easy to install and to use. In our case, it is mainly used to display errors or warnings, for example when the scanning process is suddenly interrupted.</li> <li>next-i18next:     The app doesn't have much text, and with the icons and colors it should be fairly simple to understand what you need to do. Nonetheless, we decided to add translations to the app. This is done using a Next.js plugin named i18next, that allows to translate the project easily with .JSON files.</li> <li>Crowdin:     Crowdin is a website that collects translations from users and helps translate open-source and private projects. I am especially grateful that for open-source projects, the price for this service is free. It is useful for translators to focus on translations, without the need to look at code. It also helps developers, as it automatically syncs new translations with GitHub and vice versa.</li> <li>MkDocs:     MkDocs is a Python framework used to create documentation for projects. In fact, it is the framework used to create this specific translation. It is really easy to use and makes structuralizing docs or integrating plugins like Crowdin fairly easily.</li> <li>Dependabot:     Dependabot comes with every GitHub repository, and can be activated fairly easily. Its job is to check dependencies for updates and therefore to keep the entire app up-to-date. This also ensures that the app has the latest patches and functions. By improving its dependencies, the app might become faster and more efficient. Furthermore, Dependabot also informs the user about Security vulnerabilities of used dependencies or crates, a very useful feature to maintain the app secure.</li> <li>GitHub:     GitHub has been chosen as the file hosting platform mainly because it is popular, easy to use and has everything needed. Plus it's free. A company also suggested hosting the project on their GitLab servers, but in the end the project remained on GitHub as it is easier to use and to collaborate than to use a VPN to connect to a PC that then connects to GitLab. GitHub also has a lot of features: Project planing, Milestones, Issues, Actions, ...</li> <li>CodeQL:     CodeQL is another powerful tool from GitHub. It scans the entire project and checks for vulnerabilities in the code. For example, if there is cross-site-scripting happening somewhere, or we are not hiding passwords and secrets correctly, or we are coding inefficiently. This is very useful, as it assures a certain reliability of the code.</li> <li>CodeCov:     Codecov is an external tool that can be installed on GitHub, and it tracks test coverage. It basically tells you how efficient the tests you just wrote actually are, and if they cover the entire project. Testing the frontend is hard, as we would likely need to test user interaction, but testing the backend is doable. Therefore, we set up Codecov to check our Rust backend for test coverage.</li> </ul>"},{"location":"en/developers/#integration","title":"Integration","text":"<p>Raspirus is a standalone app and everything happens inside the app. What I mean by this is that there are mo APIs for the outside to get information from, and the app is also not meant to be used by other apps. The main usage of the app is through a touchscreen, that's why there are no input fields where a user has to type text, as that is a quite frustrating experience on bad touchscreen, as the one from a Raspberry Pi.  Actually, there are API calls, but they happen inside the app. In fact, the Next.js frontend calls the backend through the Tauri API.</p> <p>For example, in the <code>loading.js</code> file, we call the scanning function from the frontend to tell Rust to start the scanner:</p> <pre><code>const message = await invoke(\"start_scanner\", {\n    path: scan_path,\n    dbfile: db_location,\n    obfuscated: obfuscatedMode,\n});\n</code></pre> <p>We basically start the <code>start_scanner</code> function and give it the needed parameters. Then we save the result in the <code>message</code> constant. This is a basic Tauri API call. </p> <p>To instead communicate from the backend back to the frontend, Tauri uses the principle of signals:</p> <pre><code>fn calculate_progress(&amp;mut self, last_percentage: &amp;mut f64, file_size: u64) {\n    self.scanned_size = self.scanned_size + file_size;\n    let scanned_percentage = (self.scanned_size as f64 / self.folder_size as f64 * 100.0).round();\n    info!(\"Scanned: {}%\", scanned_percentage);\n    if scanned_percentage != *last_percentage {\n        self.tauri_window.emit_all(\"progress\", TauriEvent {message: scanned_percentage.to_string()}).unwrap();\n        *last_percentage = scanned_percentage;\n    }\n}\n</code></pre> <p>If you want to know more about how this internal API system exactly works, you can refer to the official Tauri guide.</p>"},{"location":"en/developers/backend/","title":"Backend","text":""},{"location":"en/developers/backend/#planing","title":"Planing","text":"<p>  This diagram describes how the logical flow of the app work. The exact flow can change in the future, but this was the initial planing of the app. As you can see, it is rather simple with just a couple if statements and a for-each loop. The backend is actually not that hard to understand, the complicated part is the more in-depth part of how to manage the database, scan files, create the hash and most importantly, communicate the result to the frontend by emitting signals.</p>"},{"location":"en/developers/backend/#database","title":"Database","text":"<p>The Database consists of a single big file with mainly two columns. This file is generated at runtime and can be updated with a button on the GUI. At the time of writing, this file is approximately 4 GB in size and can take up to an hour to generate. The database contains in one column all signatures as a primary key, and in the second column the name of the file they got extracted from, based on the Virusshare database file names.</p>"},{"location":"en/developers/backend/#structure","title":"Structure","text":"<p>Here is how the database may look like:</p> MD5 Hash FileNr .... .... 40610db6af6eaf2391b7a169e2540de9 00219 64a613db4aa368108e6d4c15ef7f6454 00219 .... ...."},{"location":"en/developers/backend/#initialisation","title":"Initialisation","text":"<p>Here is the Rust code in the main.rs file that creates the Database:</p> <pre><code>let mut use_db = \"signatures.db\".to_owned();\nmatch dbfile {\n    Some(fpath) =&gt; {\n        if Path::new(&amp;fpath).to_owned().exists() &amp;&amp; Path::new(&amp;fpath).to_owned().is_file() {\n            info!(\"Using specific DB path {}\", fpath);\n            use_db = fpath.to_owned();\n        } else {\n            info!(\"Falling back to default DB file (signatures.db)\");\n        }\n    }\n    None =&gt; {\n        info!(\"Path is None; Falling back to default DB file (signatures.db)\");\n    }\n};\n</code></pre> <p>If the specified <code>signatures.db</code> file doesn't exist, it will automatically attempt to create on and even create the necessary table. You can technically also provide your own file, just put it in the same folder as the executable. Also make sure that the table is the same.</p>"},{"location":"en/developers/backend/#scanner","title":"Scanner","text":"<p>The scanner class is the main function of the entire app. It takes a directory as parameter and starts scanning it. It will scan all folders and files recursively by hashing it and checking the hash in the database.</p>"},{"location":"en/developers/backend/#ignoring-hashes-false-positives","title":"Ignoring hashes (false positives)","text":"<p>In the <code>file_scanner.rs</code> file, where the scanner is declared, we also have an Array that contains signatures that should be ignored. Virusshare is a databse where Hashes are mostly added, not removed, and therefore we need to do our filtering on the client-side. For example there was a hash for empty files, but in our opinion empty file should not be flagged as dangerous, so we added an excemption:</p> <pre><code>let false_pos: Vec&lt;String&gt; = vec![\"7dea362b3fac8e00956a4952a3d4f474\".to_owned()];\n</code></pre>"},{"location":"en/developers/backend/#obfuscated-mode","title":"Obfuscated mode","text":"<p>Sometimes, for privacy reasons, you might not want to display the path and names of the found files, therefore the scanner provides a so-called 'Obfuscated mode'. Setting this to true will make the app fail immediately as soon as it finds a vairus, without scanning the entire folder, and output red or green depending on the security of the scan.</p>"},{"location":"en/developers/backend/#logging","title":"Logging","text":"<p>The app also has a logger that keeps track of issues or warnings during the execution of the app. Sadly this only works in <code>dev</code> or <code>debug</code> mode. When packing ito an executable the logger is lost as it gets stripped away for better performance. We are nonetheless working on bringing it back to life in the future.</p>"},{"location":"en/developers/frontend/","title":"Frontend","text":""},{"location":"en/developers/frontend/#planing","title":"Planing","text":"<p>The planing of the Raspirus frontend happened on an external Website called Figma. The styling changed a bit and there are some more functions now, but the logical structure is roughly the same. Each screen you see is a single page on Next.js. Furthermore, the pop-ups have been replaced with ones from SweetAlertv2. You can explore the Figma project in the iFrame below, else if nothing is showing up, you can look at the project here.</p>"},{"location":"en/developers/frontend/#screenshots","title":"Screenshots","text":""},{"location":"en/developers/frontend/#pages","title":"Pages","text":"<p>The entire project is structurized in components and pages. The frontend is basically a normal website, so it has routing, links and so on. We have one page for each important action of the app. There is one for the scanning process, for the settings, for the informations, ... Pages link to each other and apart from the scanning and home page, they all have a button to return to the home-page. In our case we have all pages double, this has to do with an issue in the translation plugin. So now the actualy page resides inside the [lang] folder and the pages outside of it are simply used for routing. Note that there are some special pages, like the app.js and the document.js page that have a special structure. To learn more about them, visit the Next.js page about this topic</p>"},{"location":"en/developers/frontend/#components","title":"Components","text":"<p>Components are used to store repeated or cluttered code. This helps in keeping the code of the pages clean and move the focus of certain code outside of them. Each component should only fulfill a single task. For example it should display a single card in the settings page. Both components and pages are stored in different directories at root and can be imported. Only import components into pages, not the other way around.</p>"},{"location":"en/developers/frontend/#localizing","title":"Localizing","text":"<p>The frontend is also translated into different languages. The languages can be found in the public directory, where each langauge has its own folder with a json file. The JSON files are built on a key-value basis. The keys always need to be the same on all JSON files and the value gets translated. Make sure to look at the app before blindly translating, as some things might change depending of the context. For the translations, we used the Nextjs feature i18n, which works fine but is a bit complicated to setup with Tauri. If you want to add new languages, make sure to specify it in your pull-request or in the issue, as we also need tu update some of the code to cover the changes. For example we need to update the button on the main page to display the new language, this is not automatic. Here is how localizing looks like on the frontend:</p> <pre><code>Swal.fire(t(\"usb_list_error\"), t(\"usb_list_error_msg\"), \"error\");\n</code></pre> <p>In this case we are calling a SweetAlert with a title and a message. The important part is the <code>t(key)</code> function. The function will return the text associated with the given string key, if it is able to find it in the JSOn file.</p>"},{"location":"en/developers/frontend/#invoke-rust","title":"Invoke Rust","text":"<p>The frontend doesn't do any calculations, because that's what we have the Rust backend for. Rust is much faster, and also has the ability to actually access local files. But to let the frontend and the backend communicate with each other we need Tauri. Tauri offers us an API to call functions from Rust and wait for a result on the frontend. It basically works like a Promise. Here an example:</p> <pre><code>invoke(\"list_usb_drives\", {})\n  .then((output) =&gt; {\n    setDictionary(JSON.parse(output));\n    setTimeout(() =&gt; {\n      refreshButton.classList.remove(styles.refreshStart);\n    }, 3000);\n  })\n  .catch((error) =&gt; {\n    console.error(error);\n    refreshButton.classList.remove(styles.refreshStart);\n    Swal.fire(t(\"usb_list_error\"), t(\"usb_list_error_msg\"), \"error\");\n  });\n</code></pre> <p>As you can see, we use a Tauri function called <code>invoke()</code> that calls a Rust function and then awaits for it result or catches a possible error.</p>"},{"location":"de/","title":"Zuhause","text":""},{"location":"de/#willkommen-bei-raspirus-docs","title":"Willkommen bei Raspirus Docs","text":""},{"location":"de/#inhalte","title":"Inhalte:","text":"<ul> <li>Einf\u00fchrung</li> <li>Installation</li> <li>Anleitungen</li> <li>FAQ</li> <li>Nutzung und Diagramme</li> <li>Entwicklerbereich<ul> <li>Frontend (Next.JS)</li> <li>Backend (Rost)</li> </ul> </li> <li>Mitwirken<ul> <li>Coding</li> <li>\u00dcbersetzungen</li> </ul> </li> </ul>"},{"location":"de/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Dieses Projektarchiv enth\u00e4lt die gesamte Dokumentation des Raspirus Projekts. Sie befindet sich derzeit in der Entwicklung und daher nicht zu zuverl\u00e4ssig.</p>"},{"location":"de/faq/","title":"FAQ","text":""},{"location":"de/faq/#wie-generiere-ich-die-dokumentation-fur-dieses-projektarchiv","title":"Wie generiere ich die Dokumentation f\u00fcr dieses Projektarchiv?","text":"<p>You can find the generated documentation in the rust folder and in case you want to generate your own, you can do so by using the <code>cargo doc</code> command. Hier sind einige Parameter, die Sie mit ihm verwenden k\u00f6nnen: - <code>--no-deps</code>: Ignoriert Abh\u00e4ngigkeiten, dokumentiert nur den Code selbst - <code>--release</code>: Es ist im Allgemeinen besser als ein Debug - <code>--target-dir</code>: Where to output the docs All together, the command might look something like this: \\   <code>cargo doc --no-deps --release --target-dir=/docs/generated/</code></p>"},{"location":"de/faq/#wie-kann-ich-in-vscode-einen-rust-analyzer-einrichten-der-in-einer-nicht-standardmaigen-verzeichnisstruktur-arbeitet","title":"Wie kann ich in VSCode einen Rust Analyzer einrichten, der in einer nicht-standardm\u00e4\u00dfigen Verzeichnisstruktur arbeitet?","text":"<p>Das Rust Analyzer Plugin in Visual Studio Code versucht nach einer Cargo.toml Datei im aktuellen Verzeichnis oder \u00fcbergeordnetem Verzeichnis zu suchen. But since we packed the entire application in the <code>app</code> directory, it's unable to find the file and therefore might not work. This is a big lost, as it doesn't tell you if your Rust files have correct syntax or not. Um dieses Problem zu l\u00f6sen, k\u00f6nnen Sie dem Plugin eine Option hinzuf\u00fcgen und den Speicherort Ihrer Cargo.toml Datei angeben. As stated in this comment, you need to add the following lines to the end of your plugin settings' JSON. Danach m\u00fcssen Sie auch den Analyzer neu starten, damit die \u00c4nderung wirksam wird.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/matklad/tmp/hello/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"de/faq/#weitere-demnachst","title":"Weitere demn\u00e4chst","text":"<p>...</p>"},{"location":"de/guides/","title":"Anleitungen","text":""},{"location":"de/guides/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/guides/#notizen","title":"Notizen","text":""},{"location":"de/guides/#export-in-pdf","title":"Export in PDF:","text":"<ul> <li>Folgen Sie den Anweisungen f\u00fcr Ihr Betriebssystem hier: https://github.com/orzih/mkdocs-with-pdf#requirements</li> <li>Installieren Sie alle Abh\u00e4ngigkeiten mit Pip mit <code>pip install -r requirements.txt</code></li> <li><code>mkdocs build</code> ausf\u00fchren</li> <li>PDF befindet sich in site/pdf/document.pdf</li> </ul>"},{"location":"de/guides/#ubersetzungen","title":"\u00dcbersetzungen","text":"<ul> <li>Link: https://github.com/ultrabug/mkdocs-static-i18n</li> </ul>"},{"location":"de/installation/","title":"Installation","text":"<p>Diese Anleitung hilft Ihnen beim Aufbau des Projekts auf Ihrem eigenen Rechner.</p>"},{"location":"de/installation/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ul> <li>Einf\u00fchrung</li> <li>Einschr\u00e4nkungen</li> <li>Step-by-step guide</li> <li>1. Repository herunterladen</li> <li>2. Rust installieren</li> <li>3. Install NPM</li> <li>4. Next.js installieren</li> <li>5. Tauri installieren</li> <li>6. Projektabh\u00e4ngigkeiten installieren</li> <li> <p>7. Projekt erstellen</p> </li> <li> <p>Conclusion https://github.com/Raspirus/Raspirus/releases</p> </li> </ul>"},{"location":"de/installation/#einfuhrung","title":"Einf\u00fchrung","text":"<p>For people that just want a working app, they can just head over to the Release page and download the executable for the correct platform. But if you are on a different Linux distribution, unsupported OS, or just want to compile the project on your own, this step-by-step guide will guide you.</p>"},{"location":"de/installation/#einschrankungen","title":"Einschr\u00e4nkungen","text":"<ul> <li>Glibc kann unter Linux Probleme verursachen: https://tauri.app/v1/guides/building/linux#limitations</li> <li> <p>You need to use 64-bit systems, else the app might crash because it's using memory improvements that only work there</p> </li> <li> <p>The app is meant to be run as a \"I'm the only app running on this system\" app. This is important regarding RAM usage, because if you have much RAM, it will use much RAM. And if you, for some reason, try to limit the initially available RAM, the app might crash because it doesn't have the promised amount of RAM. (A future version might have a toggle for this)</p> </li> </ul>"},{"location":"de/installation/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Bitte lesen Sie die ganze Anleitung einmal, bevor Sie jeden Schritt ausf\u00fchren!</p>"},{"location":"de/installation/#1-repository-herunterladen","title":"1. Repository herunterladen","text":"<p>Dieser Schritt ist sehr einfach, einfach das ganze Projektarchiv herunterladen, indem Sie auf die gr\u00fcne Schaltfl\u00e4che auf der Homepage dieses Projektarchivs klicken. Optional k\u00f6nnen Sie auch den f\u00fcr eine Ver\u00f6ffentlichung spezifischen Code herunterladen, indem Sie die Release-Seite besuchen und die <code>.zip</code> Datei in den Assets herunterladen. Eine weitere Sache, die Sie vielleicht tun m\u00f6chten, ist dieses Projektarchiv klonen</p>"},{"location":"de/installation/#2-rust-installieren","title":"2. Rust installieren","text":"<p>Eine der Voraussetzungen, um das Projekt zu kompilieren, ist die Installation von Rst. Also make sure that your Rust installation is up-to-date with the command <code>rustup update</code>. You can check if you have Rust installed on your machine with the command <code>rustc --version</code>, if this command fails, head over to the Rust website and follow the instructions for your OS.</p>"},{"location":"de/installation/#3-install-npm","title":"3. Install NPM","text":"<p>NPM wird ben\u00f6tigt, da das Frontend der App auf JavaScript funktioniert und im Grunde eine Webseite ist. Um zu \u00fcberpr\u00fcfen, ob Node.js bereits installiert ist, f\u00fchren Sie die Befehle <code>node -v</code> und <code>npm -v</code> aus. Wenn einer von ihnen fehlschl\u00e4gt, oder Sie feststellen, dass Sie eine \u00e4ltere Version haben auf der NPM-Website installieren, um die neueste Version f\u00fcr Ihr Betriebssystem zu installieren. Wenn du ein WSL verwendest, k\u00f6nnte diese Anleitung f\u00fcr dich n\u00fctzlich sein.</p>"},{"location":"de/installation/#4-nextjs-installieren","title":"4. Next.js installieren","text":"<p>Das Frontend basiert auf JavaScript mit dem bekannten Framework Next.js, es macht die Website-Entwicklung schneller und effizienter. Sie m\u00fcssen auch dieses Tool installieren, um die Anwendung erstellen zu k\u00f6nnen. Aber keine Sorge, Sie k\u00f6nnen dies einfach mit NPM: <code>npm installieren next@latest react@latest react-dom@latest eslint-config-next@latest</code>. Dies wird Next.js, React (die Next.js basiert darauf) und ESLink installieren. Mehr \u00fcber den Installationsprozess erfahren Sie hier.</p>"},{"location":"de/installation/#5-tauri-installieren","title":"5. Tauri installieren","text":"<p>Tauri ist das Framework, das das Ruster Backend mit dem Next.js Frontend verbindet. Es ist ein Open-Source-Projekt von sehr freundlichen und gastfreundlichen Menschen. Unfortunately, installing Tauri is not as straightforward as other processes. Es ist sehr OS abh\u00e4ngig und Sie werden daher sicherstellen, dass Sie die Voraussetzungen vor dem Start erf\u00fcllen. Danach k\u00f6nnen Sie Tauri-cli installieren: <code>Fracht installiert Tauri-cli</code>. Sie k\u00f6nnten auch NPM verwenden, um es zu installieren, aber wir werden haupts\u00e4chlich mit Fracht in dieser kurzen Anleitung arbeiten. Schau dir in seinem FAQ-Bereich an, um zu erfahren, warum NPM f\u00fcr dich vielleicht besser ist.</p>"},{"location":"de/installation/#6-projektabhangigkeiten-installieren","title":"6. Projektabh\u00e4ngigkeiten installieren","text":"<p>Zun\u00e4chst werden wir die Knotenmodule installieren. Um dies zu tun, gehen Sie in das Verzeichnis, das den gesamten Raspirus-Code enth\u00e4lt. \u00d6ffnen Sie das <code>App</code> Verzeichnis, \u00f6ffnen Sie ein Terminal an diesem Ort und f\u00fchren Sie den Befehl <code>npm install</code> aus. Dies kann eine Weile dauern, aber es wird alle notwendigen Module herunterladen. Warning!: On WSL you might get an <code>OpenSSL is missing</code> error, to fix this you need to edit the file <code>app/src-tauri/Cargo.toml</code> and add the following line: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code> in the <code>[dependencies]</code> section.</p>"},{"location":"de/installation/#7-projekt-erstellen","title":"7. Projekt erstellen","text":"<p>Bevor Sie das Projekt komplett erstellen k\u00f6nnen, gibt es noch eine Sache, die Sie vielleicht \u00fcberpr\u00fcfen m\u00f6chten. To make sure that the Rust part of the project works fine, open the folder <code>app/src-tauri/</code> and execute the command <code>cargo build</code>. Wenn dieser Befehl erfolgreich ist, k\u00f6nnen Sie zum <code>app/</code> Verzeichnis zur\u00fcckkehren. Wenn dieser Befehl fehlschl\u00e4gt, \u00f6ffnen Sie bitte ein Problem in diesem Projektarchiv mit so vielen Informationen wie m\u00f6glich. Wenn alles gut gelaufen ist, befinden Sie sich jetzt im <code>App</code> Verzeichnis, und Sie k\u00f6nnen sicher den Befehl <code>cargo tauri build</code> ausf\u00fchren. Dieser Befehl erstellt die gesamte Anwendung und zeigt am Ende des Prozesses einen Pfad an, der Ihnen zeigt, wo sich die ausf\u00fchrbare Datei befindet. Standardm\u00e4\u00dfig sollten Sie es im <code>app\\src-tauri\\target\\release</code> Ordner finden k\u00f6nnen.</p>"},{"location":"de/installation/#schlussfolgerung","title":"Schlussfolgerung","text":"<p>Diese Anwendung ist im Grunde eine Website, die mit einigen Rust Code verbunden und mit dem Tauri Framework verpackt ist. Es wird daher ein grafisches Overlay ben\u00f6tigen, um die Website zu starten und anzuzeigen. Dieses Projekt befindet sich in st\u00e4ndiger Entwicklung und wenn Sie etwas Ungew\u00f6hnliches finden, haben Sie einige gute Ideen oder finden Sie einige Fehler, haben Sie keine Angst, ein Problem auf diesem Repository zu \u00f6ffnen und ich werde Ihnen gerne helfen.</p>"},{"location":"de/usage/","title":"Auslastung","text":""},{"location":"de/usage/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/contributing/","title":"Beitr\u00e4ge","text":"<p>Dieses Projekt ist komplett Open-Source und w\u00e4re ohne Ihre Hilfe nicht m\u00f6glich. Every contribution even if just a little can help a lot. Opening an issue if you find a bug, fixing the bug by opening a pull-request, adding translations, adding features and much more are all types of contributions that help the project go forward.</p>"},{"location":"de/contributing/#ubersetzungen","title":"\u00dcbersetzungen","text":"<p>The app itself is made with user-friendliness in mind and therefore doesn't have much text to translate as we want the experience to be fast without slowing down the user by forcing him/her to read lots of stuff. Nonetheless, this project still needs a lot of translators. Foremost we need translators for the docs that you are reading right now, but the app also needs translators. \u00dcbersetzungen helfen die Benutzererfahrung zu verbessern und das Projekt breiter zug\u00e4nglich zu machen. You can find out more on the dedicated page.</p>"},{"location":"de/contributing/#coding","title":"Coding","text":"<p>Die App wird haupts\u00e4chlich aus zwei Programmiersprachen gebaut: Rust und JavaScript. JavaScript is used for the frontend to build a website using the Next.JS framework and make the app look nicer and be cross-platform. The backend on the other side is written in Rust because we value speed a lot when scanning files and therefore need a fast language. To make the two communicate we use the Tauri framework. Tauri ist ein in Rust geschriebenes Open-Source-Framework, ganz neu in seinem Bereich. In Zukunft gibt es auch einen Plan, einen Python-Installer hinzuzuf\u00fcgen. If you have knowledge in any of these fields you are more than welcome to contribute to the project. Sie k\u00f6nnen dieses Projekt nat\u00fcrlich auch als Beispiel verwenden, um Ihr eigenes Projekt zu erstellen.</p>"},{"location":"de/contributing/#sponsoring","title":"Sponsoring","text":"<p>KOMMT BALD</p>"},{"location":"de/contributing/coding/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/contributing/translations/","title":"\u00dcbersetzungen","text":"<p>\u00dcbersetzungen sind sehr wichtig und k\u00f6nnen anderen Menschen helfen, die App einfacher zu verstehen und sie umfassender zur Verf\u00fcgung zu stellen. If you know a language outside of English and would like to add your translations you can do so in two ways: The first one is to translate the documentation, the second one is to translate the frontend strings.</p>"},{"location":"de/contributing/translations/#code-wird-ubersetzt","title":"Code wird \u00fcbersetzt","text":"<p>Es handelt sich um eine laufende Arbeit, die jedoch im Wesentlichen auf eine von zwei m\u00f6glichen Wegen erfolgen wird:</p>"},{"location":"de/contributing/translations/#ubersetzungsdatei","title":"\u00dcbersetzungsdatei","text":"<p>Es gibt eine \u00dcbersetzungsdatei im JSON-Format f\u00fcr jede einzelne Sprache. So the app would load the strings it needs from that file. This is a bit easier to implement for the developers, but not very efficient or great for translators, as it involves forking the repository.</p>"},{"location":"de/contributing/translations/#ubersetzungsdienst","title":"\u00dcbersetzungsdienst","text":"<p>Wir verwenden einen externen \u00dcbersetzungsdienst, um das Projekt zu \u00fcbersetzen. This option would allow translators to just translate the given strings and have an overview of how much has been translated and what still needs to be translated. Dies w\u00e4re die bevorzugte Option, aber die Kehrseite ist das Setup f\u00fcr diese Option. Since we don't know which service to use yet, this option will be added in the future when we have more concrete ideas and hopefully a bigger team. Wir werden wahrscheinlich Crowdin verwenden</p>"},{"location":"de/contributing/translations/#ubersetzungen-von-docs","title":"\u00dcbersetzungen von Docs","text":"<p>The docs you are reading right now also need translations and will require a much bigger effort than translating strings used on the frontend. Die Dokumentation ist ziemlich gro\u00df und kann daher einige Zeit in Anspruch nehmen, um zu \u00fcbersetzen. Als obige Option k\u00f6nnten wir den Service auch hier nutzen, aber das wird in Zukunft hinzugef\u00fcgt werden. If you want to start adding translations right away, I would suggest to do the following:</p> <ol> <li>Fork this repository: You can follow a guide online on how to do it properly.</li> <li>Enter the <code>docs</code> folder and, if the language you want to translate doesn't exist yet, add a new directory whose name is the name of the language you want to write translations for. For example, it would be <code>it</code> for italian, <code>de</code> for german and so on.</li> <li>Then change to that directory and edit the Markdown files inside that directory. Make sure you keep the original folder structure.</li> <li>Nachdem Sie die Bearbeitung abgeschlossen haben, speichern Sie Ihre Dateien und laden sie auf GitHub in Ihren Fork hoch. Mache einen GitHub Commit</li> <li>Jetzt k\u00f6nnen Sie eine Pull-Request in das urspr\u00fcngliche Projektarchiv \u00f6ffnen und verlangen, dass Ihre \u00c4nderungen dem Hauptprojekt hinzugef\u00fcgt werden.</li> <li>Jemand des Teams wird die \u00dcbersetzungen pr\u00fcfen und wenn akzeptiert, diese dem Hauptprojekt hinzuf\u00fcgen.</li> </ol> <p>In the future we hopefully have an external service that handles all this for you, so that you can focus on your translations without distractions. Wir werden wahrscheinlich Crowdin verwenden.</p>"},{"location":"de/developers/","title":"Entwickler","text":"<p>Das Raspirus-Projekt verwendet haupts\u00e4chlich zwei verschiedene Programmiersprachen und Frameworks. Eine f\u00fcr das Backend und eine f\u00fcr das Backend und eine f\u00fcr das Frontend. \\ Das Frontend wird unter Verwendung des Next.JS Frameworks in JavaScript geschrieben. Das Backend auf der anderen Seite ist in Rust geschrieben. The communication between these two programming languages is made using the Tauri framework. Using this framework one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"de/developers/backend/","title":"Backend","text":""},{"location":"de/developers/backend/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/developers/frontend/","title":"Frontend","text":""},{"location":"de/developers/frontend/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"it/#benvenuti-a-raspirus-docs","title":"Benvenuti a Raspirus Docs","text":""},{"location":"it/#contenuto","title":"Contenuto:","text":"<ul> <li>Introduzione</li> <li>Installazione</li> <li>Guide</li> <li>FAQ</li> <li>Uso e diagrammi</li> <li>Sezione Sviluppatori<ul> <li>Frontend (Next.JS)</li> <li>Backend (Rust)</li> </ul> </li> <li>Contribuire<ul> <li>Coding</li> <li>Traduzioni</li> </ul> </li> </ul>"},{"location":"it/#introduzione","title":"Introduzione","text":"<p>Questo repository contiene tutta la documentazione del progetto Raspirus. Attualmente \u00e8 in fase di sviluppo e quindi non \u00e8 troppo affidabile.</p>"},{"location":"it/faq/","title":"FAQ","text":""},{"location":"it/faq/#come-posso-generare-la-documentazione-per-questo-repository","title":"Come posso generare la documentazione per questo repository?","text":"<p>You can find the generated documentation in the rust folder and in case you want to generate your own, you can do so by using the <code>cargo doc</code> command. Ecco alcuni parametri che potresti voler utilizzare con esso: - <code>--no-deps</code>: Ignora le dipendenze, documenta solo il codice stesso - <code>--release</code>: Generalmente \u00e8 meglio di un debug - <code>--target-dir</code>: Where to output the docs All together, the command might look something like this: \\   <code>cargo doc --no-deps --release --target-dir=/docs/generated/</code></p>"},{"location":"it/faq/#in-vscode-come-posso-impostare-lanalizzatore-di-rust-per-lavorare-nella-struttura-di-directory-non-standard","title":"In VSCode, come posso impostare l'analizzatore di Rust per lavorare nella struttura di directory non standard?","text":"<p>Il plugin dell'analizzatore Rust in Visual Studio Code cerca di cercare un file Cargo.toml nella directory corrente o nella directory principale. But since we packed the entire application in the <code>app</code> directory, it's unable to find the file and therefore might not work. This is a big lost, as it doesn't tell you if your Rust files have correct syntax or not. Per risolvere questo problema, \u00e8 possibile aggiungere un'opzione al plugin e specificare la posizione del file Cargo.toml. As stated in this comment, you need to add the following lines to the end of your plugin settings' JSON. In seguito, dovrai anche riavviare l'analizzatore per rendere effettiva la modifica.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/matklad/tmp/hello/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"it/faq/#piu-presto-in-arrivo","title":"Pi\u00f9 presto in arrivo","text":"<p>...</p>"},{"location":"it/guides/","title":"Guide","text":""},{"location":"it/guides/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/guides/#note","title":"Note","text":""},{"location":"it/guides/#esporta-in-pdf","title":"Esporta in PDF:","text":"<ul> <li>Segui le istruzioni per il tuo sistema operativo qui: https://github.com/orzih/mkdocs-with-pdf#requirements</li> <li>Installa tutte le dipendenze usando pip con <code>pip install -r requirements.txt</code></li> <li>Esegue <code>mkdocs build</code></li> <li>PDF si trova in sito/pdf/document.pdf</li> </ul>"},{"location":"it/guides/#traduzioni","title":"Traduzioni","text":"<ul> <li>Link: https://github.com/ultrabug/mkdocs-static-i18n</li> </ul>"},{"location":"it/installation/","title":"Installazione","text":"<p>Questa guida vi aiuter\u00e0 a costruire il progetto sulla vostra macchina.</p>"},{"location":"it/installation/#tabella-dei-contenuti","title":"Tabella dei contenuti","text":"<ul> <li>Introduzione</li> <li>Limitazioni</li> <li>Step-by-step guide</li> <li>1. Scarica il repository</li> <li>2. Installa Rust</li> <li>3. Install NPM</li> <li>4. Installa Next.js</li> <li>5. Installa Tauri</li> <li>6. Installa dipendenze progetto</li> <li> <p>7. Genera il progetto</p> </li> <li> <p>Conclusion https://github.com/Raspirus/Raspirus/releases</p> </li> </ul>"},{"location":"it/installation/#introduzione","title":"Introduzione","text":"<p>For people that just want a working app, they can just head over to the Release page and download the executable for the correct platform. But if you are on a different Linux distribution, unsupported OS, or just want to compile the project on your own, this step-by-step guide will guide you.</p>"},{"location":"it/installation/#limitazioni","title":"Limitazioni","text":"<ul> <li>Glibc pu\u00f2 causare problemi su Linux: https://tauri.app/v1/guides/building/linux#limitations</li> <li> <p>You need to use 64-bit systems, else the app might crash because it's using memory improvements that only work there</p> </li> <li> <p>The app is meant to be run as a \"I'm the only app running on this system\" app. This is important regarding RAM usage, because if you have much RAM, it will use much RAM. And if you, for some reason, try to limit the initially available RAM, the app might crash because it doesn't have the promised amount of RAM. (A future version might have a toggle for this)</p> </li> </ul>"},{"location":"it/installation/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Si prega di leggere l'intera guida una volta prima di iniziare ad eseguire ogni passaggio!</p>"},{"location":"it/installation/#1-scarica-il-repository","title":"1. Scarica il repository","text":"<p>Questo passaggio \u00e8 molto semplice, basta scaricare l'intero repository facendo clic sul pulsante verde sulla homepage di questo repository. Facoltativamente, \u00e8 anche possibile scaricare codice specifico per una Rilascio, visitando la pagina Rilasciare e scaricare il file <code>.zip</code> negli asset. Un'altra cosa che potresti voler fare \u00e8 clonare questo repository</p>"},{"location":"it/installation/#2-installa-rust","title":"2. Installa Rust","text":"<p>Uno dei requisiti per compilare il progetto \u00e8 quello di avere installato Rust. Also make sure that your Rust installation is up-to-date with the command <code>rustup update</code>. You can check if you have Rust installed on your machine with the command <code>rustc --version</code>, if this command fails, head over to the Rust website and follow the instructions for your OS.</p>"},{"location":"it/installation/#3-install-npm","title":"3. Install NPM","text":"<p>NPM \u00e8 necessario perch\u00e9 il frontend dell'applicazione funziona su JavaScript ed \u00e8 fondamentalmente un sito web. Per verificare se hai gi\u00e0 installato Node.js, prova ad eseguire i comandi: <code>node -v</code> e <code>npm -v</code>. Se qualcuno di loro fallisce, o si scopre che hai una versione pi\u00f9 vecchia, vai sul sito web NPM per installare l'ultima versione per il tuo sistema operativo. Se stai usando un WSL, questa guida potrebbe essere utile per te.</p>"},{"location":"it/installation/#4-installa-nextjs","title":"4. Installa Next.js","text":"<p>Il frontend \u00e8 costruito su JavaScript utilizzando un noto framework chiamato Next.js, rende lo sviluppo del sito Web pi\u00f9 veloce ed efficiente. Sar\u00e0 necessario installare anche questo strumento per essere in grado di costruire l'applicazione. Ma non ti preoccupare, puoi farlo facilmente con NPM: <code>npm install next@latest react@latest react-dom@latest eslint-config-next@latest</code>. Questo installer\u00e0 Next.js, React (che Next.js \u00e8 basato su) e ESLint. Puoi saperne di pi\u00f9 sul processo di installazione qui.</p>"},{"location":"it/installation/#5-installa-tauri","title":"5. Installa Tauri","text":"<p>Tauri \u00e8 il framework che collega il backend Rust con il frontend Next.js. Si tratta di un progetto open-source realizzato da persone molto cordiale e accogliente. Unfortunately, installing Tauri is not as straightforward as other processes. \u00c8 molto dipendente dal sistema operativo, e quindi ti assicurerai di soddisfare i Prerequisiti prima di iniziare. In seguito, \u00e8 possibile installare Tauri suing cargo: <code>cargo install tauri-cli</code>. Si potrebbe anche utilizzare NPM per installarlo, ma lavoreremo principalmente con il carico in questa breve guida. Scopri la loro sezione FAQ per sapere perch\u00e9 NPM potrebbe essere migliore per te.</p>"},{"location":"it/installation/#6-installa-dipendenze-progetto","title":"6. Installa dipendenze progetto","text":"<p>In primo luogo, installeremo i moduli del nodo. Per fare questo, vai alla directory che contiene tutto il codice Raspirus. Apri la directory <code>app</code> , apri un terminale in questa posizione ed esegui il comando: <code>npm install</code>. Questo potrebbe richiedere un po ', ma scaricher\u00e0 tutti i moduli necessari. Warning!: On WSL you might get an <code>OpenSSL is missing</code> error, to fix this you need to edit the file <code>app/src-tauri/Cargo.toml</code> and add the following line: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code> in the <code>[dependencies]</code> section.</p>"},{"location":"it/installation/#7-genera-il-progetto","title":"7. Genera il progetto","text":"<p>Prima di poter costruire completamente il progetto, c'\u00e8 ancora una cosa che potresti voler controllare. To make sure that the Rust part of the project works fine, open the folder <code>app/src-tauri/</code> and execute the command <code>cargo build</code>. Se questo comando ha successo, puoi tornare alla directory <code>app/</code>. Se questo comando fallisce, si prega di aprire un problema su questo repository con il maggior numero possibile di informazioni sull'errore. Se tutto \u00e8 andato bene, ora sei nella directory <code>app</code> , ed \u00e8 possibile eseguire in modo sicuro il comando <code>cargo tauri build</code>. Questo comando generer\u00e0 l'intera applicazione e mostrer\u00e0 un percorso alla fine del processo mostrandoti dove si trova l'eseguibile. Per impostazione predefinita, dovresti essere in grado di trovarlo nella cartella <code>app\\src-tauri\\target\\release</code>.</p>"},{"location":"it/installation/#conclusione","title":"Conclusione","text":"<p>Questa applicazione \u00e8 fondamentalmente un sito web collegato ad alcuni codici Rust e confezionato con il framework Tauri. Sar\u00e0 quindi necessaria una sovrapposizione grafica per avviare e visualizzare il sito web. Questo progetto \u00e8 in costante sviluppo e quindi, se si trova qualcosa di insolito, avere alcune buone idee o trovare alcuni errori, non abbiate paura di aprire un problema su questo repository e sar\u00f2 felice di aiutarvi.</p>"},{"location":"it/usage/","title":"Utilizzo","text":""},{"location":"it/usage/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/contributing/","title":"Contributi","text":"<p>Questo progetto \u00e8 completamente open-source e non sarebbe possibile senza il vostro aiuto. Every contribution even if just a little can help a lot. Opening an issue if you find a bug, fixing the bug by opening a pull-request, adding translations, adding features and much more are all types of contributions that help the project go forward.</p>"},{"location":"it/contributing/#traduzioni","title":"Traduzioni","text":"<p>The app itself is made with user-friendliness in mind and therefore doesn't have much text to translate as we want the experience to be fast without slowing down the user by forcing him/her to read lots of stuff. Nonetheless, this project still needs a lot of translators. Foremost we need translators for the docs that you are reading right now, but the app also needs translators. Le traduzioni aiutano a migliorare l'esperienza utente e a rendere il progetto pi\u00f9 ampiamente disponibile. You can find out more on the dedicated page.</p>"},{"location":"it/contributing/#coding","title":"Coding","text":"<p>L'app \u00e8 costruita utilizzando principalmente due linguaggi di programmazione: Rust e JavaScript. JavaScript is used for the frontend to build a website using the Next.JS framework and make the app look nicer and be cross-platform. The backend on the other side is written in Rust because we value speed a lot when scanning files and therefore need a fast language. To make the two communicate we use the Tauri framework. Tauri \u00e8 un framework open-source scritto in Rust, abbastanza nuovo nel suo campo. In futuro c'\u00e8 anche un piano per aggiungere un programma di installazione Python. If you have knowledge in any of these fields you are more than welcome to contribute to the project. Ovviamente puoi anche usare questo progetto come esempio per creare il tuo progetto.</p>"},{"location":"it/contributing/#sponsorizzazione","title":"Sponsorizzazione","text":"<p>COMANDO SUONO</p>"},{"location":"it/contributing/coding/","title":"Codice","text":""},{"location":"it/contributing/coding/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/contributing/translations/","title":"Traduzioni","text":"<p>Le traduzioni sono molto importanti e possono aiutare altre persone a capire l'app pi\u00f9 facile e renderla pi\u00f9 ampia. If you know a language outside of English and would like to add your translations you can do so in two ways: The first one is to translate the documentation, the second one is to translate the frontend strings.</p>"},{"location":"it/contributing/translations/#tradurre-il-codice","title":"Tradurre il codice","text":"<p>Si tratta di un lavoro in corso, ma essenzialmente sar\u00e0 realizzato in uno dei due modi possibili:</p>"},{"location":"it/contributing/translations/#file-di-traduzione","title":"File di traduzione","text":"<p>C'\u00e8 un file di traduzione in formato JSON per ogni lingua differente. So the app would load the strings it needs from that file. This is a bit easier to implement for the developers, but not very efficient or great for translators, as it involves forking the repository.</p>"},{"location":"it/contributing/translations/#servizio-di-traduzione","title":"Servizio di traduzione","text":"<p>Utilizziamo un servizio di traduzioni esterne per tradurre il progetto. This option would allow translators to just translate the given strings and have an overview of how much has been translated and what still needs to be translated. Questa sarebbe l'opzione preferita, ma il lato negativo \u00e8 la configurazione di questa opzione. Since we don't know which service to use yet, this option will be added in the future when we have more concrete ideas and hopefully a bigger team. Probabilmente useremo Crowdin</p>"},{"location":"it/contributing/translations/#tradurre-documenti","title":"Tradurre Documenti","text":"<p>The docs you are reading right now also need translations and will require a much bigger effort than translating strings used on the frontend. La documentazione \u00e8 abbastanza grande e pu\u00f2 quindi richiedere un bel po' di tempo per tradurre. Come opzione di cui sopra, potremmo utilizzare il servizio anche qui, ma questo sar\u00e0 aggiunto in futuro. If you want to start adding translations right away, I would suggest to do the following:</p> <ol> <li>Fork this repository: You can follow a guide online on how to do it properly.</li> <li>Enter the <code>docs</code> folder and, if the language you want to translate doesn't exist yet, add a new directory whose name is the name of the language you want to write translations for. For example, it would be <code>it</code> for italian, <code>de</code> for german and so on.</li> <li>Then change to that directory and edit the Markdown files inside that directory. Make sure you keep the original folder structure.</li> <li>Dopo aver completato la modifica, salvare i file e caricarli sul tuo fork su GitHub. Fondamentalmente fai un commit di GitHub</li> <li>Ora puoi aprire una pull-request al repository originale e richiedere che le tue modifiche vengano aggiunte al progetto principale.</li> <li>Qualcuno del team esaminer\u00e0 le traduzioni e, se accettato, le aggiunger\u00e0 al progetto principale.</li> </ol> <p>In the future we hopefully have an external service that handles all this for you, so that you can focus on your translations without distractions. Probabilmente useremo Crowdin.</p>"},{"location":"it/developers/","title":"Sviluppatori","text":"<p>Il progetto Raspirus utilizza principalmente due linguaggi di programmazione e quadri diversi. Uno per il backend e uno per il backend e uno per il frontend. \\ Il frontend \u00e8 scritto in JavaScript utilizzando il framework Next.JS. Il backend sull'altro lato \u00e8 scritto in Rust. The communication between these two programming languages is made using the Tauri framework. Using this framework one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"it/developers/backend/","title":"Backend","text":""},{"location":"it/developers/backend/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/developers/frontend/","title":"Frontend","text":""},{"location":"it/developers/frontend/#comando-suono","title":"COMANDO SUONO","text":""}]}