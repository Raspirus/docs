{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-raspirus-docs","title":"Welcome to Raspirus Docs","text":""},{"location":"#contents","title":"Contents:","text":"<ul> <li>Introduction</li> <li>Installation</li> <li>Guides</li> <li>FAQ</li> <li>Usage and Diagrams</li> <li>Developers Section<ul> <li>Frontend (Next.js)</li> <li>Backend (Rust)</li> </ul> </li> <li>Contributing<ul> <li>Coding</li> <li>Translations</li> </ul> </li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>This repository contains all documentation of the Raspirus project. It is currently in development and therefore not too reliable.</p>"},{"location":"#related-projects","title":"Related projects","text":"<p>Raspirus is a simple virus scanner, and there are many similar projects out there. I will list a few of them I know and why I decided not to use them for my project, or why Raspirus is better.</p> <ul> <li>Clam AV: This program is an open-source Antivirus, but it can also be used like Raspirus to scan single files or folders. It surely is more accurate when it comes to search for viruses, but it is very resource intensive and a bit slow. Therefore, it is not suited for single-board computers like the Raspberry Pi, as it doesn't have enough RAM. Nonetheless, Clam AV is a great open-source tool.</li> <li>Windows Defender: This program from Windows doesn't just scan files and folders on-demand, but scans the entire system continuously. This slows down the entire system. Furthermore, it is also Windows-only, while Raspirus is cross-platform.</li> <li>Bitdefender: This is another great Antivirus software, but it comes with a cost. I think that security should be a must, not something you need to pay for. But if you are willing to pay a bit, this piece of software really has it all, and as far as I know it is even cross-platform.</li> </ul> <p>There surely are many others that I could compare here, but Raspirus is not aimed at beating other Antivirus software. Its aim is to do one thing, and do it as best as possible: Compare Hashes of a file with a list of signatures.</p> <ul> <li>This project is free and will always stay free. </li> <li>It is open-source, so you can look at the code and judge for yourself if you trust the app or not.</li> <li>Community helps grow the project, and many smart minds surely can achieve a lot if they work together</li> <li>Cross-platform as a standard: Raspirus should work everywhere</li> <li>Lightweight and fast, usable even on your Potato PC</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>In this page, we will answer your most asked questions. As more questions arise, we will expand this page to include more answers. This page is very useful if you encounter any errors during development or usage. Maybe your error can be easily fixed and doesn't require a bug report.</p>"},{"location":"faq/#what-is-the-icon-of-the-project","title":"What is the Icon of the project?","text":"<p> In case you didn't notice yet, this is the logo of the Raspirus app. It was generated with DALL-E and some creative image editing and merging. It should represent a red monster that eats viruses. His name is Stuart by the way, and don't worry, he is a very kind monster, except for when he is hungry, then you better feed him viruses. You can find more media and documents in the dedicated repository. You are free to use these images to create your own art and showcase them in the discussion boards</p>"},{"location":"faq/#how-do-i-generate-the-documentation-for-this-repository","title":"How do I generate the documentation for this repository?","text":"<p>You can find the generated documentation in the rust folder and in case you want to generate your own, you can do so by using the <code>cargo doc</code> command. Here are some parameters you might want to use with it: - <code>--no-deps</code>: Ignores dependencies, only documents the code itself - <code>--release</code>: It is generally better than a debug - <code>--target-dir</code>: Where to output the docs All together, the command might look something like this: \\   <code>cargo doc --no-deps --release --target-dir=/docs/generated/</code></p>"},{"location":"faq/#in-vs-code-how-do-i-set-up-rust-analyzer-to-work-in-non-standard-directory-structure","title":"In VS Code, how do I set up Rust analyzer to work in non-standard directory structure?","text":"<p>The Rust analyzer plugin in Visual Studio Code tries to search for a Cargo.toml file in the current directory, or parent directory. But since we packed the entire application in the <code>app</code> directory, it's unable to find the file and therefore might not work. This is a big lost, as it doesn't tell you if your Rust files have correct syntax or not. To solve this issue, you can add an option to the plugin and specify the location of your Cargo.toml file. As stated in this comment, you need to add the following lines to the end of your plugin settings' JSON. Afterward, you will also need to restart the Analyzer for the modification to take effect.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/matklad/tmp/hello/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"faq/#updating-database-crashes-app","title":"Updating database crashes app","text":"<p>On Windows, it seems like the app crashes when the user tries to update the database. We are aware of this issue and working to fix it. The issue arises because the function needs administrative privileges, which Windows isn't providing. To fix this issue for now, simply execute the app in administration mode, aka. With admin privileges. You can do so by right-clicking the app and clicking <code>Run as administrator</code>.</p>"},{"location":"guides/","title":"Guides","text":""},{"location":"guides/#coming-soon","title":"COMING SOON","text":""},{"location":"guides/#notes","title":"Notes","text":""},{"location":"guides/#export-to-pdf","title":"Export to PDF:","text":"<ul> <li>Follow instructions for your OS on here: https://github.com/orzih/mkdocs-with-pdf#requirements</li> <li>Install all dependencies using pip with <code>pip install -r requirements.txt</code></li> <li>Run <code>mkdocs build</code></li> <li>PDF is located in site/pdf/document.pdf</li> </ul>"},{"location":"guides/#translations","title":"Translations","text":"<ul> <li>Link: https://github.com/ultrabug/mkdocs-static-i18n</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This guide will help you in building the project on your own machine.</p>"},{"location":"installation/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Limitations</li> <li>Step-by-step guide</li> <li>1. Download the repository</li> <li>2. Install Rust</li> <li>3. Install NPM</li> <li>4. Install Next.js</li> <li>5. Install Tauri</li> <li>6. Install project dependencies</li> <li> <p>7. Build the project</p> </li> <li> <p>Conclusion https://github.com/Raspirus/Raspirus/releases</p> </li> </ul>"},{"location":"installation/#introduction","title":"Introduction","text":"<p>For people that just want a working app, they can just head over to the Release page and download the executable for the correct platform. But if you are on a different Linux distribution, unsupported OS, or just want to compile the project on your own, this step-by-step guide will guide you.</p>"},{"location":"installation/#limitations","title":"Limitations","text":"<ul> <li>Glibc can cause problems on Linux: https://tauri.app/v1/guides/building/linux#limitations</li> <li> <p>You need to use 64-bit systems, else the app might crash because it's using memory improvements that only work there</p> </li> <li> <p>The app is meant to be run as a \"I'm the only app running on this system\" app. This is important regarding RAM usage, because if you have much RAM, it will use much RAM. And if you, for some reason, try to limit the initially available RAM, the app might crash because it doesn't have the promised amount of RAM. (A future version might have a toggle for this)</p> </li> </ul>"},{"location":"installation/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Please read the whole guide once before starting to execute each step!</p>"},{"location":"installation/#1-download-the-repository","title":"1. Download the repository","text":"<p>This step is very straightforward, just download the whole repository by clicking the green button on the homepage of this repository. Optionally, you can also download code specific to a Release by visiting the Release page and download the <code>.zip</code> file in the assets. Another thing you might want to do is clone this repository</p>"},{"location":"installation/#2-install-rust","title":"2. Install Rust","text":"<p>One of the requirements to compile the project is to have Rust installed. You can check if you have Rust installed on your machine with the command <code>rustc --version</code>, if this command fails, head over to the Rust website and follow the instructions for your OS. Also make sure that your Rust installation is up-to-date with the command <code>rustup update</code>.</p>"},{"location":"installation/#3-install-npm","title":"3. Install NPM","text":"<p>NPM is needed because the frontend of the app works on JavaScript and is basically a website. To check if you already have Node.js installed, try executing the commands: <code>node -v</code> and <code>npm -v</code>. If any of them fail, or you find out you have an older version, head over to the NPM Website to install the latest version for your OS. If you are using a WSL, this guide might be useful to you.</p>"},{"location":"installation/#4-install-nextjs","title":"4. Install Next.js","text":"<p>The frontend is built on JavaScript using a well-known framework named Next.js, it makes website development faster and more efficient. You will need to install this tool too to be able to build the application. But don't worry, you can do this easily with NPM: <code>npm install next@latest react@latest react-dom@latest eslint-config-next@latest</code>. This will install Next.js, React (which Next.js is based on) and ESLint. You can learn more about the installation process here.</p>"},{"location":"installation/#5-install-tauri","title":"5. Install Tauri","text":"<p>Tauri is the framework that connects the Rust backend with the Next.js frontend. It is an open-source project made by very friendly and welcoming people. Unfortunately, installing Tauri is not as straightforward as other processes. It is very OS dependent, and you will therefore make sure that you meet the Prerequisites before you start. Afterward, you can install Tauri suing cargo: <code>cargo install tauri-cli</code>. You could also use NPM to install it, but we will mainly work with cargo in this short guide. Check out their FAQ section to learn about why NPM might be better for you.</p>"},{"location":"installation/#6-install-project-dependencies","title":"6. Install project dependencies","text":"<p>Firstly, we will install the node modules. To do this, head over to the directory that contains all the Raspirus code. Open the <code>app</code> directory, open a terminal in this location and execute the command: <code>npm install</code>. This might take a while, but it will download all the necessary modules. Warning!: On WSL you might get an <code>OpenSSL is missing</code> error, to fix this you need to edit the file <code>app/src-tauri/Cargo.toml</code> and add the following line: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code> in the <code>[dependencies]</code> section.</p>"},{"location":"installation/#7-build-the-project","title":"7. Build the project","text":"<p>Before you can completely build the project, there is one more thing you might want to check. To make sure that the Rust part of the project works fine, open the folder <code>app/src-tauri/</code> and execute the command <code>cargo build</code>. If this command succeeds, you can go back to the <code>app/</code> directory. If this command fails, please open an issue on this repository with as much information about the error as possible. If everything went well, you are now in the <code>app</code> directory, and you can safely execute the command <code>cargo tauri build</code>. This command will build the entire application and display a path at the end of the process showing you where the executable is located. By default, you should be able to find it in the <code>app\\src-tauri\\target\\release</code> folder.</p>"},{"location":"installation/#conclusion","title":"Conclusion","text":"<p>This application is basically a website attached to some Rust code and packaged with the Tauri framework. It will therefore need a graphical overlay to start and display the website. This project is in constant development and therefore, if you find anything unusual, have some good ideas or find some errors, don't be afraid to open an issue on this repository and I will be happy to help you out.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#tutorial","title":"Tutorial","text":"<p>How to use this app. It is super easy</p>"},{"location":"usage/#case-study","title":"Case study","text":"<p>COMING SOON - Some metrics about the projects - Speed - Reliability - Functions, where to use this project</p>"},{"location":"contributing/","title":"Contributions","text":"<p>This project is entirely open-source and wouldn't be possible without your help. Every contribution, even if just a little, can help a lot. Opening an issue if you find a bug, fixing the bug by opening a pull-request, adding translations, adding features and much more are all types of contributions that help the project go forward.</p>"},{"location":"contributing/#translations","title":"Translations","text":"<p>The app itself is made with user-friendliness in mind and therefore doesn't have much text to translate, as we want the experience to be fast without slowing down the user by forcing him/her to read lots of stuff. Nonetheless, this project still needs a lot of translators. Foremost, we need translators for the docs that you are reading right now, but the app also needs translators. Translations help improve the user experience and make the project more widely available. You can find out more on the dedicated page.</p>"},{"location":"contributing/#coding","title":"Coding","text":"<p>The app is built using mainly two programming languages: Rust and JavaScript. JavaScript is used for the frontend to build a website using the Next.js framework and make the app look nicer and be cross-platform. The backend on the other side is written in Rust because we value speed a lot when scanning files and therefore need a fast language. To make the two communicate, we use the Tauri framework. Tauri is an open-source framework written in Rust, quite new in its field. In the future, there is also a plan to add a Python installer. If you have knowledge in any of these fields, you are more than welcome to contribute to the project. You can obviously also use this project as an example to create your own project.</p>"},{"location":"contributing/#sponsoring","title":"Sponsoring","text":"<p>COMING SOON</p>"},{"location":"contributing/coding/","title":"Code","text":""},{"location":"contributing/coding/#coming-soon","title":"COMING SOON","text":""},{"location":"contributing/translations/","title":"Translations.md","text":""},{"location":"contributing/translations/#comments-true","title":"comments: true","text":""},{"location":"contributing/translations/#translations","title":"Translations","text":"<p>Translations are very important and can help other people understand the app easier and make it wider available. If you know a language outside of English and would like to add your translations, you can do so in two ways: The first one is to translate the documentation, the second one is to translate the frontend strings.</p>"},{"location":"contributing/translations/#translating-code","title":"Translating code","text":"<p>This is a work in progress, but essentially it will be done in one of two possible ways:</p>"},{"location":"contributing/translations/#translation-file","title":"Translation file","text":"<p>There is a translations file in JSON format for each different language. So the app would load the strings it needs from that file. This is a bit easier to implement for the developers, but not very efficient or great for translators, as it involves forking the repository.</p>"},{"location":"contributing/translations/#translation-service","title":"Translation service","text":"<p>We use an external translations service to translate the project. This option would allow translators to just translate the given strings and have an overview of how much has been translated and what still needs to be translated. This would be the preferred option, but the downside is the setup for this option. Since we don't know which service to use yet, this option will be added in the future when we have more concrete ideas and hopefully a bigger team. We will probably use Crowdin</p>"},{"location":"contributing/translations/#translating-docs","title":"Translating Docs","text":"<p>The docs you are reading right now also need translations and will require a much bigger effort than translating strings used on the frontend. The documentation is quite big and can therefore take quite some time to translate. As the option above, we could use the service here too, but that will be added in the future. If you want to start adding translations right away, I would suggest doing the following:</p> <ol> <li>Fork this repository: You can follow a guide online on how to do it properly.</li> <li>Enter the <code>docs</code> folder and, if the language you want to translate doesn't exist yet, add a new directory whose name is the name of the language you want to write translations for. For example, it would be <code>it</code> for Italian, <code>de</code> for German and so on.</li> <li>Then change to that directory and edit the Markdown files inside that directory. Make sure you keep the original folder structure.</li> <li>After you have finished editing, save your files and upload them to your fork on GitHub. Basically make a GitHub commit</li> <li>Now you can open a pull-request to the original repository and request that your changes get added to the main project.</li> <li>Someone of the team will review the translations and if accepted add them to the main project.</li> </ol> <p>In the future, we hopefully have an external service that handles all this for you, so that you can focus on your translations without distractions. We will probably use Crowdin.</p>"},{"location":"developers/","title":"Developers","text":"<p>The Raspirus project mainly uses two different programming languages and frameworks. One for the backend and one for the backend and one for the frontend. \\ The frontend is written in JavaScript using the Next.js framework. The backend on the other side is written in Rust. The communication between these two programming languages is made using the Tauri framework. Using this framework, one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"developers/#technologies-used","title":"Technologies used","text":"<ul> <li>NPM:     I wanted the frontend to be beautiful, and at first I tried creating an actual native application, but that just didn't have the customization I was searching for. Therefore, I decided to write a Web-frontend, and for that I could choose between Node.js or Deno. I ended up using Node.js as it's the one I am mostly familiar with.</li> <li>Next.js:     Next.js is a frontend framework that is fairly easy to implement, and once setup can be very powerful. The most useful feature used in this project is the export of the website in static HTML. This is essential for Tauri to function. Another advantage of Next.js is that it optimizes itself, by automatically stripping away everything unnecessary, this makes the app lightweight and fast. Navigation with Next.js is practically instant.</li> <li>Rust:     Rust was not my first choice for the backend. At first, I started with C++, but I was not skilled enough to create the entire app with that language, so I turned to Python. Python is way slower than C++, but it's my favorite language and the one I know best, so I was able to develop faster. Nonetheless, the lack of speed with Python was a big drawback. Luckily, a friend of mine helped me out and rewrote the entire backend in Rust, basically speeding the app up by 100x. What previously took a couple of minutes, now took mere seconds. Rust is a compiled language and faster than Python, which is an interpreted language. If you want to test the old Python system, there is an entire repository for that.</li> <li>Tauri:     Tauri plays a very important part in this project, as it is a framework that allows connecting the Rust backend to a JavaScript frontend. This essentially allowed us to have a beautiful frontend in Next.js and an impressively fast backend in Rust. Furthermore, Tauri compiles the application for different systems, like Windows, Linux or macOS by creating installers or binaries. This improved the installation of the app.</li> <li>SweetAlertv2:     When errors occur, or there are warnings and information to display as a pop-up to the user, the simple JavaScript alert just doesn't look that good. SweetAlert improves the look of these pop-ups by a lot. It's fairly easy to install and to use. In our case, it is mainly used to display errors or warnings, for example when the scanning process is suddenly interrupted.</li> <li>next-i18next:     The app doesn't have much text, and with the icons and colors it should be fairly simple to understand what you need to do. Nonetheless, we decided to add translations to the app. This is done using a Next.js plugin named i18next, that allows to translate the project easily with .JSON files.</li> <li>Crowdin:     Crowdin is a website that collects translations from users and helps translate open-source and private projects. I am especially grateful that for open-source projects, the price for this service is free. It is useful for translators to focus on translations, without the need to look at code. It also helps developers, as it automatically syncs new translations with GitHub and vice versa.</li> <li>MkDocs:     MkDocs is a Python framework used to create documentation for projects. In fact, it is the framework used to create this specific translation. It is really easy to use and makes structuralizing docs or integrating plugins like Crowdin fairly easily.</li> <li>Dependabot:     Dependabot comes with every GitHub repository, and can be activated fairly easily. Its job is to check dependencies for updates and therefore to keep the entire app up-to-date. This also ensures that the app has the latest patches and functions. By improving its dependencies, the app might become faster and more efficient. Furthermore, Dependabot also informs the user about Security vulnerabilities of used dependencies or crates, a very useful feature to maintain the app secure.</li> <li>GitHub:     GitHub has been chosen as the file hosting platform mainly because it is popular, easy to use and has everything needed. Plus it's free. A company also suggested hosting the project on their GitLab servers, but in the end the project remained on GitHub as it is easier to use and to collaborate than to use a VPN to connect to a PC that then connects to GitLab. GitHub also has a lot of features: Project planing, Milestones, Issues, Actions, ...</li> <li>CodeQL:     CodeQL is another powerful tool from GitHub. It scans the entire project and checks for vulnerabilities in the code. For example, if there is cross-site-scripting happening somewhere, or we are not hiding passwords and secrets correctly, or we are coding inefficiently. This is very useful, as it assures a certain reliability of the code.</li> <li>CodeCov:     Codecov is an external tool that can be installed on GitHub, and it tracks test coverage. It basically tells you how efficient the tests you just wrote actually are, and if they cover the entire project. Testing the frontend is hard, as we would likely need to test user interaction, but testing the backend is doable. Therefore, we set up Codecov to check our Rust backend for test coverage.</li> </ul>"},{"location":"developers/#integration","title":"Integration","text":"<p>Raspirus is a standalone app and everything happens inside the app. What I mean by this is that there are mo APIs for the outside to get information from, and the app is also not meant to be used by other apps. The main usage of the app is through a touchscreen, that's why there are no input fields where a user has to type text, as that is a quite frustrating experience on bad touchscreen, as the one from a Raspberry Pi.  Actually, there are API calls, but they happen inside the app. In fact, the Next.js frontend calls the backend through the Tauri API.</p> <p>For example, in the <code>loading.js</code> file, we call the scanning function from the frontend to tell Rust to start the scanner:</p> <pre><code>const message = await invoke(\"start_scanner\", {\n    path: scan_path,\n    dbfile: db_location,\n    obfuscated: obfuscatedMode,\n});\n</code></pre> <p>We basically start the <code>start_scanner</code> function and give it the needed parameters. Then we save the result in the <code>message</code> constant. This is a basic Tauri API call. </p> <p>To instead communicate from the backend back to the frontend, Tauri uses the principle of signals:</p> <pre><code>fn calculate_progress(&amp;mut self, last_percentage: &amp;mut f64, file_size: u64) {\n    self.scanned_size = self.scanned_size + file_size;\n    let scanned_percentage = (self.scanned_size as f64 / self.folder_size as f64 * 100.0).round();\n    info!(\"Scanned: {}%\", scanned_percentage);\n    if scanned_percentage != *last_percentage {\n        self.tauri_window.emit_all(\"progress\", TauriEvent {message: scanned_percentage.to_string()}).unwrap();\n        *last_percentage = scanned_percentage;\n    }\n}\n</code></pre> <p>If you want to know more about how this internal API system exactly works, you can refer to the official Tauri guide.</p>"},{"location":"developers/backend/","title":"Backend","text":""},{"location":"developers/backend/#planing","title":"Planing","text":"<p>  This diagram describes how the logical flow of the app work. The exact flow can change in the future, but this was the initial planing of the app. As you can see, it is rather simple with just a couple if statements and a for-each loop. The backend is actually not that hard to understand, the complicated part is the more in-depth part of how to manage the database, scan files, create the hash and most importantly, communicate the result to the frontend by emitting signals.</p>"},{"location":"developers/backend/#database","title":"Database","text":""},{"location":"developers/backend/#scanner","title":"Scanner","text":""},{"location":"developers/backend/#logging","title":"Logging","text":""},{"location":"developers/frontend/","title":"Frontend","text":""},{"location":"developers/frontend/#planing","title":"Planing","text":"<p>The planing of the Raspirus frontend happened on an external Website called Figma. The styling changed a bit and there are some more functions now, but the logical structure is roughly the same. Each screen you see is a single page on Next.js. Furthermore, the pop-ups have been replaced with ones from SweetAlertv2. You can explore the Figma project in the iFrame below, else if nothing is showing up, you can look at the project here.</p>"},{"location":"developers/frontend/#screenshots","title":"Screenshots","text":""},{"location":"developers/frontend/#pages","title":"Pages","text":""},{"location":"developers/frontend/#components","title":"Components","text":""},{"location":"developers/frontend/#localizing","title":"Localizing","text":""},{"location":"developers/frontend/#invoke-rust","title":"Invoke Rust","text":""},{"location":"en/developers/","title":"Developers","text":"<p>The Raspirus project mainly uses two different programming languages and frameworks. One for the backend and one for the backend and one for the frontend. \\ The frontend is written in JavaScript using the Next.js framework. The backend on the other side is written in Rust. The communication between these two programming languages is made using the Tauri framework. Using this framework, one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"en/developers/#technologies-used","title":"Technologies used","text":"<ul> <li>NPM:     I wanted the frontend to be beautiful, and at first I tried creating an actual native application, but that just didn't have the customization I was searching for. Therefore, I decided to write a Web-frontend, and for that I could choose between Node.js or Deno. I ended up using Node.js as it's the one I am mostly familiar with.</li> <li>Next.js:     Next.js is a frontend framework that is fairly easy to implement, and once setup can be very powerful. The most useful feature used in this project is the export of the website in static HTML. This is essential for Tauri to function. Another advantage of Next.js is that it optimizes itself, by automatically stripping away everything unnecessary, this makes the app lightweight and fast. Navigation with Next.js is practically instant.</li> <li>Rust:     Rust was not my first choice for the backend. At first, I started with C++, but I was not skilled enough to create the entire app with that language, so I turned to Python. Python is way slower than C++, but it's my favorite language and the one I know best, so I was able to develop faster. Nonetheless, the lack of speed with Python was a big drawback. Luckily, a friend of mine helped me out and rewrote the entire backend in Rust, basically speeding the app up by 100x. What previously took a couple of minutes, now took mere seconds. Rust is a compiled language and faster than Python, which is an interpreted language. If you want to test the old Python system, there is an entire repository for that.</li> <li>Tauri:     Tauri plays a very important part in this project, as it is a framework that allows connecting the Rust backend to a JavaScript frontend. This essentially allowed us to have a beautiful frontend in Next.js and an impressively fast backend in Rust. Furthermore, Tauri compiles the application for different systems, like Windows, Linux or macOS by creating installers or binaries. This improved the installation of the app.</li> <li>SweetAlertv2:     When errors occur, or there are warnings and information to display as a pop-up to the user, the simple JavaScript alert just doesn't look that good. SweetAlert improves the look of these pop-ups by a lot. It's fairly easy to install and to use. In our case, it is mainly used to display errors or warnings, for example when the scanning process is suddenly interrupted.</li> <li>next-i18next:     The app doesn't have much text, and with the icons and colors it should be fairly simple to understand what you need to do. Nonetheless, we decided to add translations to the app. This is done using a Next.js plugin named i18next, that allows to translate the project easily with .JSON files.</li> <li>Crowdin:     Crowdin is a website that collects translations from users and helps translate open-source and private projects. I am especially grateful that for open-source projects, the price for this service is free. It is useful for translators to focus on translations, without the need to look at code. It also helps developers, as it automatically syncs new translations with GitHub and vice versa.</li> <li>MkDocs:     MkDocs is a Python framework used to create documentation for projects. In fact, it is the framework used to create this specific translation. It is really easy to use and makes structuralizing docs or integrating plugins like Crowdin fairly easily.</li> <li>Dependabot:     Dependabot comes with every GitHub repository, and can be activated fairly easily. Its job is to check dependencies for updates and therefore to keep the entire app up-to-date. This also ensures that the app has the latest patches and functions. By improving its dependencies, the app might become faster and more efficient. Furthermore, Dependabot also informs the user about Security vulnerabilities of used dependencies or crates, a very useful feature to maintain the app secure.</li> <li>GitHub:     GitHub has been chosen as the file hosting platform mainly because it is popular, easy to use and has everything needed. Plus it's free. A company also suggested hosting the project on their GitLab servers, but in the end the project remained on GitHub as it is easier to use and to collaborate than to use a VPN to connect to a PC that then connects to GitLab. GitHub also has a lot of features: Project planing, Milestones, Issues, Actions, ...</li> <li>CodeQL:     CodeQL is another powerful tool from GitHub. It scans the entire project and checks for vulnerabilities in the code. For example, if there is cross-site-scripting happening somewhere, or we are not hiding passwords and secrets correctly, or we are coding inefficiently. This is very useful, as it assures a certain reliability of the code.</li> <li>CodeCov:     Codecov is an external tool that can be installed on GitHub, and it tracks test coverage. It basically tells you how efficient the tests you just wrote actually are, and if they cover the entire project. Testing the frontend is hard, as we would likely need to test user interaction, but testing the backend is doable. Therefore, we set up Codecov to check our Rust backend for test coverage.</li> </ul>"},{"location":"en/developers/#integration","title":"Integration","text":"<p>Raspirus is a standalone app and everything happens inside the app. What I mean by this is that there are mo APIs for the outside to get information from, and the app is also not meant to be used by other apps. The main usage of the app is through a touchscreen, that's why there are no input fields where a user has to type text, as that is a quite frustrating experience on bad touchscreen, as the one from a Raspberry Pi.  Actually, there are API calls, but they happen inside the app. In fact, the Next.js frontend calls the backend through the Tauri API.</p> <p>For example, in the <code>loading.js</code> file, we call the scanning function from the frontend to tell Rust to start the scanner:</p> <pre><code>const message = await invoke(\"start_scanner\", {\n    path: scan_path,\n    dbfile: db_location,\n    obfuscated: obfuscatedMode,\n});\n</code></pre> <p>We basically start the <code>start_scanner</code> function and give it the needed parameters. Then we save the result in the <code>message</code> constant. This is a basic Tauri API call. </p> <p>To instead communicate from the backend back to the frontend, Tauri uses the principle of signals:</p> <pre><code>fn calculate_progress(&amp;mut self, last_percentage: &amp;mut f64, file_size: u64) {\n    self.scanned_size = self.scanned_size + file_size;\n    let scanned_percentage = (self.scanned_size as f64 / self.folder_size as f64 * 100.0).round();\n    info!(\"Scanned: {}%\", scanned_percentage);\n    if scanned_percentage != *last_percentage {\n        self.tauri_window.emit_all(\"progress\", TauriEvent {message: scanned_percentage.to_string()}).unwrap();\n        *last_percentage = scanned_percentage;\n    }\n}\n</code></pre> <p>If you want to know more about how this internal API system exactly works, you can refer to the official Tauri guide.</p>"},{"location":"en/developers/backend/","title":"Backend","text":""},{"location":"en/developers/backend/#planing","title":"Planing","text":"<p>  This diagram describes how the logical flow of the app work. The exact flow can change in the future, but this was the initial planing of the app. As you can see, it is rather simple with just a couple if statements and a for-each loop. The backend is actually not that hard to understand, the complicated part is the more in-depth part of how to manage the database, scan files, create the hash and most importantly, communicate the result to the frontend by emitting signals.</p>"},{"location":"en/developers/backend/#database","title":"Database","text":""},{"location":"en/developers/backend/#scanner","title":"Scanner","text":""},{"location":"en/developers/backend/#logging","title":"Logging","text":""},{"location":"en/developers/frontend/","title":"Frontend","text":""},{"location":"en/developers/frontend/#planing","title":"Planing","text":"<p>The planing of the Raspirus frontend happened on an external Website called Figma. The styling changed a bit and there are some more functions now, but the logical structure is roughly the same. Each screen you see is a single page on Next.js. Furthermore, the pop-ups have been replaced with ones from SweetAlertv2. You can explore the Figma project in the iFrame below, else if nothing is showing up, you can look at the project here.</p>"},{"location":"en/developers/frontend/#screenshots","title":"Screenshots","text":""},{"location":"en/developers/frontend/#pages","title":"Pages","text":""},{"location":"en/developers/frontend/#components","title":"Components","text":""},{"location":"en/developers/frontend/#localizing","title":"Localizing","text":""},{"location":"en/developers/frontend/#invoke-rust","title":"Invoke Rust","text":""},{"location":"de/","title":"Zuhause","text":""},{"location":"de/#willkommen-bei-raspirus-docs","title":"Willkommen bei Raspirus Docs","text":""},{"location":"de/#inhalte","title":"Inhalte:","text":"<ul> <li>Einf\u00fchrung</li> <li>Installation</li> <li>Anleitungen</li> <li>FAQ</li> <li>Nutzung und Diagramme</li> <li>Entwicklerbereich<ul> <li>Frontend (Next.JS)</li> <li>Backend (Rost)</li> </ul> </li> <li>Mitwirken<ul> <li>Coding</li> <li>\u00dcbersetzungen</li> </ul> </li> </ul>"},{"location":"de/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Dieses Projektarchiv enth\u00e4lt die gesamte Dokumentation des Raspirus Projekts. Sie befindet sich derzeit in der Entwicklung und daher nicht zu zuverl\u00e4ssig.</p>"},{"location":"de/faq/","title":"FAQ","text":""},{"location":"de/faq/#wie-generiere-ich-die-dokumentation-fur-dieses-projektarchiv","title":"Wie generiere ich die Dokumentation f\u00fcr dieses Projektarchiv?","text":"<p>You can find the generated documentation in the rust folder and in case you want to generate your own, you can do so by using the <code>cargo doc</code> command. Hier sind einige Parameter, die Sie mit ihm verwenden k\u00f6nnen: - <code>--no-deps</code>: Ignoriert Abh\u00e4ngigkeiten, dokumentiert nur den Code selbst - <code>--release</code>: Es ist im Allgemeinen besser als ein Debug - <code>--target-dir</code>: Where to output the docs All together, the command might look something like this: \\   <code>cargo doc --no-deps --release --target-dir=/docs/generated/</code></p>"},{"location":"de/faq/#wie-kann-ich-in-vscode-einen-rust-analyzer-einrichten-der-in-einer-nicht-standardmaigen-verzeichnisstruktur-arbeitet","title":"Wie kann ich in VSCode einen Rust Analyzer einrichten, der in einer nicht-standardm\u00e4\u00dfigen Verzeichnisstruktur arbeitet?","text":"<p>Das Rust Analyzer Plugin in Visual Studio Code versucht nach einer Cargo.toml Datei im aktuellen Verzeichnis oder \u00fcbergeordnetem Verzeichnis zu suchen. But since we packed the entire application in the <code>app</code> directory, it's unable to find the file and therefore might not work. This is a big lost, as it doesn't tell you if your Rust files have correct syntax or not. Um dieses Problem zu l\u00f6sen, k\u00f6nnen Sie dem Plugin eine Option hinzuf\u00fcgen und den Speicherort Ihrer Cargo.toml Datei angeben. As stated in this comment, you need to add the following lines to the end of your plugin settings' JSON. Danach m\u00fcssen Sie auch den Analyzer neu starten, damit die \u00c4nderung wirksam wird.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/matklad/tmp/hello/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"de/faq/#weitere-demnachst","title":"Weitere demn\u00e4chst","text":"<p>...</p>"},{"location":"de/guides/","title":"Anleitungen","text":""},{"location":"de/guides/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/guides/#notizen","title":"Notizen","text":""},{"location":"de/guides/#export-in-pdf","title":"Export in PDF:","text":"<ul> <li>Folgen Sie den Anweisungen f\u00fcr Ihr Betriebssystem hier: https://github.com/orzih/mkdocs-with-pdf#requirements</li> <li>Installieren Sie alle Abh\u00e4ngigkeiten mit Pip mit <code>pip install -r requirements.txt</code></li> <li><code>mkdocs build</code> ausf\u00fchren</li> <li>PDF befindet sich in site/pdf/document.pdf</li> </ul>"},{"location":"de/guides/#ubersetzungen","title":"\u00dcbersetzungen","text":"<ul> <li>Link: https://github.com/ultrabug/mkdocs-static-i18n</li> </ul>"},{"location":"de/installation/","title":"Installation","text":"<p>Diese Anleitung hilft Ihnen beim Aufbau des Projekts auf Ihrem eigenen Rechner.</p>"},{"location":"de/installation/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ul> <li>Einf\u00fchrung</li> <li>Einschr\u00e4nkungen</li> <li>Step-by-step guide</li> <li>1. Repository herunterladen</li> <li>2. Rust installieren</li> <li>3. Install NPM</li> <li>4. Next.js installieren</li> <li>5. Tauri installieren</li> <li>6. Projektabh\u00e4ngigkeiten installieren</li> <li> <p>7. Projekt erstellen</p> </li> <li> <p>Conclusion https://github.com/Raspirus/Raspirus/releases</p> </li> </ul>"},{"location":"de/installation/#einfuhrung","title":"Einf\u00fchrung","text":"<p>For people that just want a working app, they can just head over to the Release page and download the executable for the correct platform. But if you are on a different Linux distribution, unsupported OS, or just want to compile the project on your own, this step-by-step guide will guide you.</p>"},{"location":"de/installation/#einschrankungen","title":"Einschr\u00e4nkungen","text":"<ul> <li>Glibc kann unter Linux Probleme verursachen: https://tauri.app/v1/guides/building/linux#limitations</li> <li> <p>You need to use 64-bit systems, else the app might crash because it's using memory improvements that only work there</p> </li> <li> <p>The app is meant to be run as a \"I'm the only app running on this system\" app. This is important regarding RAM usage, because if you have much RAM, it will use much RAM. And if you, for some reason, try to limit the initially available RAM, the app might crash because it doesn't have the promised amount of RAM. (A future version might have a toggle for this)</p> </li> </ul>"},{"location":"de/installation/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Bitte lesen Sie die ganze Anleitung einmal, bevor Sie jeden Schritt ausf\u00fchren!</p>"},{"location":"de/installation/#1-repository-herunterladen","title":"1. Repository herunterladen","text":"<p>Dieser Schritt ist sehr einfach, einfach das ganze Projektarchiv herunterladen, indem Sie auf die gr\u00fcne Schaltfl\u00e4che auf der Homepage dieses Projektarchivs klicken. Optional k\u00f6nnen Sie auch den f\u00fcr eine Ver\u00f6ffentlichung spezifischen Code herunterladen, indem Sie die Release-Seite besuchen und die <code>.zip</code> Datei in den Assets herunterladen. Eine weitere Sache, die Sie vielleicht tun m\u00f6chten, ist dieses Projektarchiv klonen</p>"},{"location":"de/installation/#2-rust-installieren","title":"2. Rust installieren","text":"<p>Eine der Voraussetzungen, um das Projekt zu kompilieren, ist die Installation von Rst. Also make sure that your Rust installation is up-to-date with the command <code>rustup update</code>. You can check if you have Rust installed on your machine with the command <code>rustc --version</code>, if this command fails, head over to the Rust website and follow the instructions for your OS.</p>"},{"location":"de/installation/#3-install-npm","title":"3. Install NPM","text":"<p>NPM wird ben\u00f6tigt, da das Frontend der App auf JavaScript funktioniert und im Grunde eine Webseite ist. Um zu \u00fcberpr\u00fcfen, ob Node.js bereits installiert ist, f\u00fchren Sie die Befehle <code>node -v</code> und <code>npm -v</code> aus. Wenn einer von ihnen fehlschl\u00e4gt, oder Sie feststellen, dass Sie eine \u00e4ltere Version haben auf der NPM-Website installieren, um die neueste Version f\u00fcr Ihr Betriebssystem zu installieren. Wenn du ein WSL verwendest, k\u00f6nnte diese Anleitung f\u00fcr dich n\u00fctzlich sein.</p>"},{"location":"de/installation/#4-nextjs-installieren","title":"4. Next.js installieren","text":"<p>Das Frontend basiert auf JavaScript mit dem bekannten Framework Next.js, es macht die Website-Entwicklung schneller und effizienter. Sie m\u00fcssen auch dieses Tool installieren, um die Anwendung erstellen zu k\u00f6nnen. Aber keine Sorge, Sie k\u00f6nnen dies einfach mit NPM: <code>npm installieren next@latest react@latest react-dom@latest eslint-config-next@latest</code>. Dies wird Next.js, React (die Next.js basiert darauf) und ESLink installieren. Mehr \u00fcber den Installationsprozess erfahren Sie hier.</p>"},{"location":"de/installation/#5-tauri-installieren","title":"5. Tauri installieren","text":"<p>Tauri ist das Framework, das das Ruster Backend mit dem Next.js Frontend verbindet. Es ist ein Open-Source-Projekt von sehr freundlichen und gastfreundlichen Menschen. Unfortunately, installing Tauri is not as straightforward as other processes. Es ist sehr OS abh\u00e4ngig und Sie werden daher sicherstellen, dass Sie die Voraussetzungen vor dem Start erf\u00fcllen. Danach k\u00f6nnen Sie Tauri-cli installieren: <code>Fracht installiert Tauri-cli</code>. Sie k\u00f6nnten auch NPM verwenden, um es zu installieren, aber wir werden haupts\u00e4chlich mit Fracht in dieser kurzen Anleitung arbeiten. Schau dir in seinem FAQ-Bereich an, um zu erfahren, warum NPM f\u00fcr dich vielleicht besser ist.</p>"},{"location":"de/installation/#6-projektabhangigkeiten-installieren","title":"6. Projektabh\u00e4ngigkeiten installieren","text":"<p>Zun\u00e4chst werden wir die Knotenmodule installieren. Um dies zu tun, gehen Sie in das Verzeichnis, das den gesamten Raspirus-Code enth\u00e4lt. \u00d6ffnen Sie das <code>App</code> Verzeichnis, \u00f6ffnen Sie ein Terminal an diesem Ort und f\u00fchren Sie den Befehl <code>npm install</code> aus. Dies kann eine Weile dauern, aber es wird alle notwendigen Module herunterladen. Warning!: On WSL you might get an <code>OpenSSL is missing</code> error, to fix this you need to edit the file <code>app/src-tauri/Cargo.toml</code> and add the following line: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code> in the <code>[dependencies]</code> section.</p>"},{"location":"de/installation/#7-projekt-erstellen","title":"7. Projekt erstellen","text":"<p>Bevor Sie das Projekt komplett erstellen k\u00f6nnen, gibt es noch eine Sache, die Sie vielleicht \u00fcberpr\u00fcfen m\u00f6chten. To make sure that the Rust part of the project works fine, open the folder <code>app/src-tauri/</code> and execute the command <code>cargo build</code>. Wenn dieser Befehl erfolgreich ist, k\u00f6nnen Sie zum <code>app/</code> Verzeichnis zur\u00fcckkehren. Wenn dieser Befehl fehlschl\u00e4gt, \u00f6ffnen Sie bitte ein Problem in diesem Projektarchiv mit so vielen Informationen wie m\u00f6glich. Wenn alles gut gelaufen ist, befinden Sie sich jetzt im <code>App</code> Verzeichnis, und Sie k\u00f6nnen sicher den Befehl <code>cargo tauri build</code> ausf\u00fchren. Dieser Befehl erstellt die gesamte Anwendung und zeigt am Ende des Prozesses einen Pfad an, der Ihnen zeigt, wo sich die ausf\u00fchrbare Datei befindet. Standardm\u00e4\u00dfig sollten Sie es im <code>app\\src-tauri\\target\\release</code> Ordner finden k\u00f6nnen.</p>"},{"location":"de/installation/#schlussfolgerung","title":"Schlussfolgerung","text":"<p>Diese Anwendung ist im Grunde eine Website, die mit einigen Rust Code verbunden und mit dem Tauri Framework verpackt ist. Es wird daher ein grafisches Overlay ben\u00f6tigen, um die Website zu starten und anzuzeigen. Dieses Projekt befindet sich in st\u00e4ndiger Entwicklung und wenn Sie etwas Ungew\u00f6hnliches finden, haben Sie einige gute Ideen oder finden Sie einige Fehler, haben Sie keine Angst, ein Problem auf diesem Repository zu \u00f6ffnen und ich werde Ihnen gerne helfen.</p>"},{"location":"de/usage/","title":"Auslastung","text":""},{"location":"de/usage/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/contributing/","title":"Beitr\u00e4ge","text":"<p>Dieses Projekt ist komplett Open-Source und w\u00e4re ohne Ihre Hilfe nicht m\u00f6glich. Every contribution even if just a little can help a lot. Opening an issue if you find a bug, fixing the bug by opening a pull-request, adding translations, adding features and much more are all types of contributions that help the project go forward.</p>"},{"location":"de/contributing/#ubersetzungen","title":"\u00dcbersetzungen","text":"<p>The app itself is made with user-friendliness in mind and therefore doesn't have much text to translate as we want the experience to be fast without slowing down the user by forcing him/her to read lots of stuff. Nonetheless, this project still needs a lot of translators. Foremost we need translators for the docs that you are reading right now, but the app also needs translators. \u00dcbersetzungen helfen die Benutzererfahrung zu verbessern und das Projekt breiter zug\u00e4nglich zu machen. You can find out more on the dedicated page.</p>"},{"location":"de/contributing/#coding","title":"Coding","text":"<p>Die App wird haupts\u00e4chlich aus zwei Programmiersprachen gebaut: Rust und JavaScript. JavaScript is used for the frontend to build a website using the Next.JS framework and make the app look nicer and be cross-platform. The backend on the other side is written in Rust because we value speed a lot when scanning files and therefore need a fast language. To make the two communicate we use the Tauri framework. Tauri ist ein in Rust geschriebenes Open-Source-Framework, ganz neu in seinem Bereich. In Zukunft gibt es auch einen Plan, einen Python-Installer hinzuzuf\u00fcgen. If you have knowledge in any of these fields you are more than welcome to contribute to the project. Sie k\u00f6nnen dieses Projekt nat\u00fcrlich auch als Beispiel verwenden, um Ihr eigenes Projekt zu erstellen.</p>"},{"location":"de/contributing/#sponsoring","title":"Sponsoring","text":"<p>KOMMT BALD</p>"},{"location":"de/contributing/coding/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/contributing/translations/","title":"\u00dcbersetzungen","text":"<p>\u00dcbersetzungen sind sehr wichtig und k\u00f6nnen anderen Menschen helfen, die App einfacher zu verstehen und sie umfassender zur Verf\u00fcgung zu stellen. If you know a language outside of English and would like to add your translations you can do so in two ways: The first one is to translate the documentation, the second one is to translate the frontend strings.</p>"},{"location":"de/contributing/translations/#code-wird-ubersetzt","title":"Code wird \u00fcbersetzt","text":"<p>Es handelt sich um eine laufende Arbeit, die jedoch im Wesentlichen auf eine von zwei m\u00f6glichen Wegen erfolgen wird:</p>"},{"location":"de/contributing/translations/#ubersetzungsdatei","title":"\u00dcbersetzungsdatei","text":"<p>Es gibt eine \u00dcbersetzungsdatei im JSON-Format f\u00fcr jede einzelne Sprache. So the app would load the strings it needs from that file. This is a bit easier to implement for the developers, but not very efficient or great for translators, as it involves forking the repository.</p>"},{"location":"de/contributing/translations/#ubersetzungsdienst","title":"\u00dcbersetzungsdienst","text":"<p>Wir verwenden einen externen \u00dcbersetzungsdienst, um das Projekt zu \u00fcbersetzen. This option would allow translators to just translate the given strings and have an overview of how much has been translated and what still needs to be translated. Dies w\u00e4re die bevorzugte Option, aber die Kehrseite ist das Setup f\u00fcr diese Option. Since we don't know which service to use yet, this option will be added in the future when we have more concrete ideas and hopefully a bigger team. Wir werden wahrscheinlich Crowdin verwenden</p>"},{"location":"de/contributing/translations/#ubersetzungen-von-docs","title":"\u00dcbersetzungen von Docs","text":"<p>The docs you are reading right now also need translations and will require a much bigger effort than translating strings used on the frontend. Die Dokumentation ist ziemlich gro\u00df und kann daher einige Zeit in Anspruch nehmen, um zu \u00fcbersetzen. Als obige Option k\u00f6nnten wir den Service auch hier nutzen, aber das wird in Zukunft hinzugef\u00fcgt werden. If you want to start adding translations right away, I would suggest to do the following:</p> <ol> <li>Fork this repository: You can follow a guide online on how to do it properly.</li> <li>Enter the <code>docs</code> folder and, if the language you want to translate doesn't exist yet, add a new directory whose name is the name of the language you want to write translations for. For example, it would be <code>it</code> for italian, <code>de</code> for german and so on.</li> <li>Then change to that directory and edit the Markdown files inside that directory. Make sure you keep the original folder structure.</li> <li>Nachdem Sie die Bearbeitung abgeschlossen haben, speichern Sie Ihre Dateien und laden sie auf GitHub in Ihren Fork hoch. Mache einen GitHub Commit</li> <li>Jetzt k\u00f6nnen Sie eine Pull-Request in das urspr\u00fcngliche Projektarchiv \u00f6ffnen und verlangen, dass Ihre \u00c4nderungen dem Hauptprojekt hinzugef\u00fcgt werden.</li> <li>Jemand des Teams wird die \u00dcbersetzungen pr\u00fcfen und wenn akzeptiert, diese dem Hauptprojekt hinzuf\u00fcgen.</li> </ol> <p>In the future we hopefully have an external service that handles all this for you, so that you can focus on your translations without distractions. Wir werden wahrscheinlich Crowdin verwenden.</p>"},{"location":"de/developers/","title":"Entwickler","text":"<p>Das Raspirus-Projekt verwendet haupts\u00e4chlich zwei verschiedene Programmiersprachen und Frameworks. Eine f\u00fcr das Backend und eine f\u00fcr das Backend und eine f\u00fcr das Frontend. \\ Das Frontend wird unter Verwendung des Next.JS Frameworks in JavaScript geschrieben. Das Backend auf der anderen Seite ist in Rust geschrieben. The communication between these two programming languages is made using the Tauri framework. Using this framework one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"de/developers/backend/","title":"Backend","text":""},{"location":"de/developers/backend/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"de/developers/frontend/","title":"Frontend","text":""},{"location":"de/developers/frontend/#kommt-bald","title":"KOMMT BALD","text":""},{"location":"it/#benvenuti-a-raspirus-docs","title":"Benvenuti a Raspirus Docs","text":""},{"location":"it/#contenuto","title":"Contenuto:","text":"<ul> <li>Introduzione</li> <li>Installazione</li> <li>Guide</li> <li>FAQ</li> <li>Uso e diagrammi</li> <li>Sezione Sviluppatori<ul> <li>Frontend (Next.JS)</li> <li>Backend (Rust)</li> </ul> </li> <li>Contribuire<ul> <li>Coding</li> <li>Traduzioni</li> </ul> </li> </ul>"},{"location":"it/#introduzione","title":"Introduzione","text":"<p>Questo repository contiene tutta la documentazione del progetto Raspirus. Attualmente \u00e8 in fase di sviluppo e quindi non \u00e8 troppo affidabile.</p>"},{"location":"it/faq/","title":"FAQ","text":""},{"location":"it/faq/#come-posso-generare-la-documentazione-per-questo-repository","title":"Come posso generare la documentazione per questo repository?","text":"<p>You can find the generated documentation in the rust folder and in case you want to generate your own, you can do so by using the <code>cargo doc</code> command. Ecco alcuni parametri che potresti voler utilizzare con esso: - <code>--no-deps</code>: Ignora le dipendenze, documenta solo il codice stesso - <code>--release</code>: Generalmente \u00e8 meglio di un debug - <code>--target-dir</code>: Where to output the docs All together, the command might look something like this: \\   <code>cargo doc --no-deps --release --target-dir=/docs/generated/</code></p>"},{"location":"it/faq/#in-vscode-come-posso-impostare-lanalizzatore-di-rust-per-lavorare-nella-struttura-di-directory-non-standard","title":"In VSCode, come posso impostare l'analizzatore di Rust per lavorare nella struttura di directory non standard?","text":"<p>Il plugin dell'analizzatore Rust in Visual Studio Code cerca di cercare un file Cargo.toml nella directory corrente o nella directory principale. But since we packed the entire application in the <code>app</code> directory, it's unable to find the file and therefore might not work. This is a big lost, as it doesn't tell you if your Rust files have correct syntax or not. Per risolvere questo problema, \u00e8 possibile aggiungere un'opzione al plugin e specificare la posizione del file Cargo.toml. As stated in this comment, you need to add the following lines to the end of your plugin settings' JSON. In seguito, dovrai anche riavviare l'analizzatore per rendere effettiva la modifica.</p> <pre><code>{\n    \"rust-analyzer.linkedProjects\": [\n        \"/home/matklad/tmp/hello/Cargo.toml\"\n    ]\n}\n</code></pre>"},{"location":"it/faq/#piu-presto-in-arrivo","title":"Pi\u00f9 presto in arrivo","text":"<p>...</p>"},{"location":"it/guides/","title":"Guide","text":""},{"location":"it/guides/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/guides/#note","title":"Note","text":""},{"location":"it/guides/#esporta-in-pdf","title":"Esporta in PDF:","text":"<ul> <li>Segui le istruzioni per il tuo sistema operativo qui: https://github.com/orzih/mkdocs-with-pdf#requirements</li> <li>Installa tutte le dipendenze usando pip con <code>pip install -r requirements.txt</code></li> <li>Esegue <code>mkdocs build</code></li> <li>PDF si trova in sito/pdf/document.pdf</li> </ul>"},{"location":"it/guides/#traduzioni","title":"Traduzioni","text":"<ul> <li>Link: https://github.com/ultrabug/mkdocs-static-i18n</li> </ul>"},{"location":"it/installation/","title":"Installazione","text":"<p>Questa guida vi aiuter\u00e0 a costruire il progetto sulla vostra macchina.</p>"},{"location":"it/installation/#tabella-dei-contenuti","title":"Tabella dei contenuti","text":"<ul> <li>Introduzione</li> <li>Limitazioni</li> <li>Step-by-step guide</li> <li>1. Scarica il repository</li> <li>2. Installa Rust</li> <li>3. Install NPM</li> <li>4. Installa Next.js</li> <li>5. Installa Tauri</li> <li>6. Installa dipendenze progetto</li> <li> <p>7. Genera il progetto</p> </li> <li> <p>Conclusion https://github.com/Raspirus/Raspirus/releases</p> </li> </ul>"},{"location":"it/installation/#introduzione","title":"Introduzione","text":"<p>For people that just want a working app, they can just head over to the Release page and download the executable for the correct platform. But if you are on a different Linux distribution, unsupported OS, or just want to compile the project on your own, this step-by-step guide will guide you.</p>"},{"location":"it/installation/#limitazioni","title":"Limitazioni","text":"<ul> <li>Glibc pu\u00f2 causare problemi su Linux: https://tauri.app/v1/guides/building/linux#limitations</li> <li> <p>You need to use 64-bit systems, else the app might crash because it's using memory improvements that only work there</p> </li> <li> <p>The app is meant to be run as a \"I'm the only app running on this system\" app. This is important regarding RAM usage, because if you have much RAM, it will use much RAM. And if you, for some reason, try to limit the initially available RAM, the app might crash because it doesn't have the promised amount of RAM. (A future version might have a toggle for this)</p> </li> </ul>"},{"location":"it/installation/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Si prega di leggere l'intera guida una volta prima di iniziare ad eseguire ogni passaggio!</p>"},{"location":"it/installation/#1-scarica-il-repository","title":"1. Scarica il repository","text":"<p>Questo passaggio \u00e8 molto semplice, basta scaricare l'intero repository facendo clic sul pulsante verde sulla homepage di questo repository. Facoltativamente, \u00e8 anche possibile scaricare codice specifico per una Rilascio, visitando la pagina Rilasciare e scaricare il file <code>.zip</code> negli asset. Un'altra cosa che potresti voler fare \u00e8 clonare questo repository</p>"},{"location":"it/installation/#2-installa-rust","title":"2. Installa Rust","text":"<p>Uno dei requisiti per compilare il progetto \u00e8 quello di avere installato Rust. Also make sure that your Rust installation is up-to-date with the command <code>rustup update</code>. You can check if you have Rust installed on your machine with the command <code>rustc --version</code>, if this command fails, head over to the Rust website and follow the instructions for your OS.</p>"},{"location":"it/installation/#3-install-npm","title":"3. Install NPM","text":"<p>NPM \u00e8 necessario perch\u00e9 il frontend dell'applicazione funziona su JavaScript ed \u00e8 fondamentalmente un sito web. Per verificare se hai gi\u00e0 installato Node.js, prova ad eseguire i comandi: <code>node -v</code> e <code>npm -v</code>. Se qualcuno di loro fallisce, o si scopre che hai una versione pi\u00f9 vecchia, vai sul sito web NPM per installare l'ultima versione per il tuo sistema operativo. Se stai usando un WSL, questa guida potrebbe essere utile per te.</p>"},{"location":"it/installation/#4-installa-nextjs","title":"4. Installa Next.js","text":"<p>Il frontend \u00e8 costruito su JavaScript utilizzando un noto framework chiamato Next.js, rende lo sviluppo del sito Web pi\u00f9 veloce ed efficiente. Sar\u00e0 necessario installare anche questo strumento per essere in grado di costruire l'applicazione. Ma non ti preoccupare, puoi farlo facilmente con NPM: <code>npm install next@latest react@latest react-dom@latest eslint-config-next@latest</code>. Questo installer\u00e0 Next.js, React (che Next.js \u00e8 basato su) e ESLint. Puoi saperne di pi\u00f9 sul processo di installazione qui.</p>"},{"location":"it/installation/#5-installa-tauri","title":"5. Installa Tauri","text":"<p>Tauri \u00e8 il framework che collega il backend Rust con il frontend Next.js. Si tratta di un progetto open-source realizzato da persone molto cordiale e accogliente. Unfortunately, installing Tauri is not as straightforward as other processes. \u00c8 molto dipendente dal sistema operativo, e quindi ti assicurerai di soddisfare i Prerequisiti prima di iniziare. In seguito, \u00e8 possibile installare Tauri suing cargo: <code>cargo install tauri-cli</code>. Si potrebbe anche utilizzare NPM per installarlo, ma lavoreremo principalmente con il carico in questa breve guida. Scopri la loro sezione FAQ per sapere perch\u00e9 NPM potrebbe essere migliore per te.</p>"},{"location":"it/installation/#6-installa-dipendenze-progetto","title":"6. Installa dipendenze progetto","text":"<p>In primo luogo, installeremo i moduli del nodo. Per fare questo, vai alla directory che contiene tutto il codice Raspirus. Apri la directory <code>app</code> , apri un terminale in questa posizione ed esegui il comando: <code>npm install</code>. Questo potrebbe richiedere un po ', ma scaricher\u00e0 tutti i moduli necessari. Warning!: On WSL you might get an <code>OpenSSL is missing</code> error, to fix this you need to edit the file <code>app/src-tauri/Cargo.toml</code> and add the following line: <code>openssl-sys = {version = \"0.9.66\", features = [\"vendored\"]}</code> in the <code>[dependencies]</code> section.</p>"},{"location":"it/installation/#7-genera-il-progetto","title":"7. Genera il progetto","text":"<p>Prima di poter costruire completamente il progetto, c'\u00e8 ancora una cosa che potresti voler controllare. To make sure that the Rust part of the project works fine, open the folder <code>app/src-tauri/</code> and execute the command <code>cargo build</code>. Se questo comando ha successo, puoi tornare alla directory <code>app/</code>. Se questo comando fallisce, si prega di aprire un problema su questo repository con il maggior numero possibile di informazioni sull'errore. Se tutto \u00e8 andato bene, ora sei nella directory <code>app</code> , ed \u00e8 possibile eseguire in modo sicuro il comando <code>cargo tauri build</code>. Questo comando generer\u00e0 l'intera applicazione e mostrer\u00e0 un percorso alla fine del processo mostrandoti dove si trova l'eseguibile. Per impostazione predefinita, dovresti essere in grado di trovarlo nella cartella <code>app\\src-tauri\\target\\release</code>.</p>"},{"location":"it/installation/#conclusione","title":"Conclusione","text":"<p>Questa applicazione \u00e8 fondamentalmente un sito web collegato ad alcuni codici Rust e confezionato con il framework Tauri. Sar\u00e0 quindi necessaria una sovrapposizione grafica per avviare e visualizzare il sito web. Questo progetto \u00e8 in costante sviluppo e quindi, se si trova qualcosa di insolito, avere alcune buone idee o trovare alcuni errori, non abbiate paura di aprire un problema su questo repository e sar\u00f2 felice di aiutarvi.</p>"},{"location":"it/usage/","title":"Utilizzo","text":""},{"location":"it/usage/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/contributing/","title":"Contributi","text":"<p>Questo progetto \u00e8 completamente open-source e non sarebbe possibile senza il vostro aiuto. Every contribution even if just a little can help a lot. Opening an issue if you find a bug, fixing the bug by opening a pull-request, adding translations, adding features and much more are all types of contributions that help the project go forward.</p>"},{"location":"it/contributing/#traduzioni","title":"Traduzioni","text":"<p>The app itself is made with user-friendliness in mind and therefore doesn't have much text to translate as we want the experience to be fast without slowing down the user by forcing him/her to read lots of stuff. Nonetheless, this project still needs a lot of translators. Foremost we need translators for the docs that you are reading right now, but the app also needs translators. Le traduzioni aiutano a migliorare l'esperienza utente e a rendere il progetto pi\u00f9 ampiamente disponibile. You can find out more on the dedicated page.</p>"},{"location":"it/contributing/#coding","title":"Coding","text":"<p>L'app \u00e8 costruita utilizzando principalmente due linguaggi di programmazione: Rust e JavaScript. JavaScript is used for the frontend to build a website using the Next.JS framework and make the app look nicer and be cross-platform. The backend on the other side is written in Rust because we value speed a lot when scanning files and therefore need a fast language. To make the two communicate we use the Tauri framework. Tauri \u00e8 un framework open-source scritto in Rust, abbastanza nuovo nel suo campo. In futuro c'\u00e8 anche un piano per aggiungere un programma di installazione Python. If you have knowledge in any of these fields you are more than welcome to contribute to the project. Ovviamente puoi anche usare questo progetto come esempio per creare il tuo progetto.</p>"},{"location":"it/contributing/#sponsorizzazione","title":"Sponsorizzazione","text":"<p>COMANDO SUONO</p>"},{"location":"it/contributing/coding/","title":"Codice","text":""},{"location":"it/contributing/coding/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/contributing/translations/","title":"Traduzioni","text":"<p>Le traduzioni sono molto importanti e possono aiutare altre persone a capire l'app pi\u00f9 facile e renderla pi\u00f9 ampia. If you know a language outside of English and would like to add your translations you can do so in two ways: The first one is to translate the documentation, the second one is to translate the frontend strings.</p>"},{"location":"it/contributing/translations/#tradurre-il-codice","title":"Tradurre il codice","text":"<p>Si tratta di un lavoro in corso, ma essenzialmente sar\u00e0 realizzato in uno dei due modi possibili:</p>"},{"location":"it/contributing/translations/#file-di-traduzione","title":"File di traduzione","text":"<p>C'\u00e8 un file di traduzione in formato JSON per ogni lingua differente. So the app would load the strings it needs from that file. This is a bit easier to implement for the developers, but not very efficient or great for translators, as it involves forking the repository.</p>"},{"location":"it/contributing/translations/#servizio-di-traduzione","title":"Servizio di traduzione","text":"<p>Utilizziamo un servizio di traduzioni esterne per tradurre il progetto. This option would allow translators to just translate the given strings and have an overview of how much has been translated and what still needs to be translated. Questa sarebbe l'opzione preferita, ma il lato negativo \u00e8 la configurazione di questa opzione. Since we don't know which service to use yet, this option will be added in the future when we have more concrete ideas and hopefully a bigger team. Probabilmente useremo Crowdin</p>"},{"location":"it/contributing/translations/#tradurre-documenti","title":"Tradurre Documenti","text":"<p>The docs you are reading right now also need translations and will require a much bigger effort than translating strings used on the frontend. La documentazione \u00e8 abbastanza grande e pu\u00f2 quindi richiedere un bel po' di tempo per tradurre. Come opzione di cui sopra, potremmo utilizzare il servizio anche qui, ma questo sar\u00e0 aggiunto in futuro. If you want to start adding translations right away, I would suggest to do the following:</p> <ol> <li>Fork this repository: You can follow a guide online on how to do it properly.</li> <li>Enter the <code>docs</code> folder and, if the language you want to translate doesn't exist yet, add a new directory whose name is the name of the language you want to write translations for. For example, it would be <code>it</code> for italian, <code>de</code> for german and so on.</li> <li>Then change to that directory and edit the Markdown files inside that directory. Make sure you keep the original folder structure.</li> <li>Dopo aver completato la modifica, salvare i file e caricarli sul tuo fork su GitHub. Fondamentalmente fai un commit di GitHub</li> <li>Ora puoi aprire una pull-request al repository originale e richiedere che le tue modifiche vengano aggiunte al progetto principale.</li> <li>Qualcuno del team esaminer\u00e0 le traduzioni e, se accettato, le aggiunger\u00e0 al progetto principale.</li> </ol> <p>In the future we hopefully have an external service that handles all this for you, so that you can focus on your translations without distractions. Probabilmente useremo Crowdin.</p>"},{"location":"it/developers/","title":"Sviluppatori","text":"<p>Il progetto Raspirus utilizza principalmente due linguaggi di programmazione e quadri diversi. Uno per il backend e uno per il backend e uno per il frontend. \\ Il frontend \u00e8 scritto in JavaScript utilizzando il framework Next.JS. Il backend sull'altro lato \u00e8 scritto in Rust. The communication between these two programming languages is made using the Tauri framework. Using this framework one can write functions in Rust and call them from the frontend easily.</p>"},{"location":"it/developers/backend/","title":"Backend","text":""},{"location":"it/developers/backend/#comando-suono","title":"COMANDO SUONO","text":""},{"location":"it/developers/frontend/","title":"Frontend","text":""},{"location":"it/developers/frontend/#comando-suono","title":"COMANDO SUONO","text":""}]}